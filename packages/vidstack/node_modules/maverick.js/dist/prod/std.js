import { isFunction, isArray, onDispose, noop } from './chunks/maverick--Z7w4fcm.js';
export { DOMEvent, EventTriggers, EventsController, EventsTarget, anySignal, appendTriggerEvent, attachDeclarativeShadowDOM, createComment, createFragment, createRegex, findTriggerEvent, getOriginEvent, getSlottedChildren, hasTriggerEvent, isBoolean, isDOMElement, isDOMEvent, isDOMFragment, isDOMNode, isKeyboardClick, isKeyboardEvent, isMouseEvent, isNil, isNull, isNumber, isObject, isPointerEvent, isString, isTouchEvent, isUndefined, isWindow, listenEvent, setAttribute, setStyle, toggleClass, walkTriggerEventChain, wasEnterKeyPressed, wasEscapeKeyPressed } from './chunks/maverick--Z7w4fcm.js';
export { run, runAll } from './chunks/maverick-6LqLvq_5.js';
export { camelToKebabCase, camelToTitleCase, kebabToCamelCase, kebabToPascalCase, kebabToTitleCase, lowercaseFirstLetter, trimTrailingSemicolon, uppercaseFirstChar } from './chunks/maverick-jhjCtVsR.js';

/**
 * Unwraps possible function calls and returns the value. It will return the value if the given
 * argument is not a function.
 */
function unwrap(fn) {
  return isFunction(fn) ? fn() : fn;
}

/**
 * Recursively unwraps possible function calls and returns the final value. It will return
 * the value if the given argument is not a function.
 */
function unwrapDeep( fn) {
  let value = fn;
  while (typeof value === 'function') value = value.call(this);
  return value;
}

function ariaBool(value) {
  return value ? 'true' : 'false';
}

// This only exists because array.flat(Infinity) is slow.
function flattenArray(array) {
  const flat = [];

  for (let i = 0; i < array.length; i++) {
    if (isArray(array[i])) {
      flat.push(...flattenArray(array[i] ));
    } else if (array[i] || array[i] === 0) {
      flat.push(array[i] );
    }
  }

  return flat;
}

/**
 * Creates and returns a disposal bin for managing cleanup operations.
 *
 * @example
 * ```ts
 * const bin = createDisposalBin();
 * // Add callbacks
 * bin.add(() => {});
 * bin.add(() => {});
 * // Empty bin by running callbacks
 * bin.empty();
 * ```
 */
function createDisposalBin() {
  const disposal = new Set();
  return {
    add(...callbacks) {
      for (const callback of callbacks) disposal.add(callback);
    },
    empty() {
      for (const callback of disposal) callback();
      disposal.clear();
    },
  };
}

/**
 * Creates and return a `DisposalBin`. This bin is emptied if the parent scope is disposed of.
 */
function useDisposalBin() {
  const disposal = createDisposalBin();
  onDispose(disposal.empty);
  return disposal;
}

function keysOf(obj) {
  return Object.keys(obj ) ;
}



















/**
 * Merges properties of the given `sources` together into a single object. All enumerable properties
 * are merged including values, getters, setters, and methods.
 */
function mergeProperties(...sources) {
  const target = {} ;

  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    if (source) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    }
  }

  return target;
}

/**
 * Creates a new object composed of the picked `source` properties. All enumerable properties
 * are merged including values, getters, setters, and methods.
 */
function pick(source, props) {
  const target = {} ;

  for (const prop of props) {
    Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
  }

  return target;
}

/**
 * The opposite of `pick`; this function creates a new object composed of the `source` properties
 * that are not included in the given `props` argument. All enumerable properties are merged
 * including values, getters, setters, and methods.
 */
function omit(source, props) {
  return pick(
    source,
    keysOf(source).filter((key) => !props.includes(key )),
  );
}

/**
 * Creates an empty Promise and defers resolving/rejecting it.
 */
function deferredPromise()


 {
  let resolve, reject;

  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });

  return { promise, resolve, reject };
}

/**
 * Wraps a promise so it can timeout.
 */
function timedPromise(
  promise,
  timeout,
  timeoutMsg,
) {
  const timer = new Promise((_, reject) => {
    const timerId = setTimeout(() => {
      clearTimeout(timerId);
      reject(timeoutMsg);
    }, timeout);
  });

  return Promise.race([promise, timer]) ;
}

/**
 * Resolves after the given `delay` timeout has passed.
 */
function waitTimeout(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}

/**
 * Requests an animation frame and waits for it to be resolved. This is safe to call server-side,
 * no action will be performed.
 *
 * @param callback - Invoked on the next animation frame.
 */
function waitAnimationFrame(callback) {
  return new Promise((resolve) => {
    window.requestAnimationFrame((time) => {
      callback?.(time);
      resolve();
    });
  });
}

/**
 * Creates a throttled function that only invokes `func` at most once per animation frame. This is
 * a noop server-side.
 *
 * @param func - The function to throttle.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
 */
function animationFrameThrottle(func) {

  let id = -1,
    lastArgs;

  function throttle( ...args) {
    lastArgs = args;
    if (id >= 0) return;
    id = window.requestAnimationFrame(() => {
      func.apply(this, lastArgs );
      id = -1;
      lastArgs = undefined;
    });
  }

  return throttle ;
}

const requestIdleCallback = typeof window !== 'undefined'
  ? 'requestIdleCallback' in window
    ? window.requestIdleCallback
    : (cb) => window.setTimeout(cb, 1)
  : noop;

/**
 * Queues and waits for a function to be called during a browser's idle periods. This enables
 * developers to perform background and low priority work on the main event loop, without impacting
 * latency-critical events such as animation and input response. Functions are generally called in
 * first-in-first-out order; however, callbacks which have a `timeout` specified may be called
 * out-of-order if necessary in order to run them before the timeout elapses.
 *
 * - If `requestIdleCallback` is not available, this function will wait for a new animation frame.
 * - This is safe to call server-side, the given `callback` won't be invoked.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback}
 */
function waitIdlePeriod(
  callback,
  options,
) {
  return new Promise((resolve) => {
    requestIdleCallback((deadline) => {
      callback?.(deadline);
      resolve();
    }, options);
  });
}

export { animationFrameThrottle, ariaBool, createDisposalBin, deferredPromise, flattenArray, isArray, isFunction, keysOf, mergeProperties, noop, omit, pick, timedPromise, unwrap, unwrapDeep, useDisposalBin, waitAnimationFrame, waitIdlePeriod, waitTimeout };
