import * as React from 'react';

const IS_SERVER = typeof document === 'undefined';

const SCOPE = Symbol("SCOPE" );

let scheduledEffects = false, runningEffects = false, currentScope = null, currentObserver = null, currentObservers = null, currentObserversIndex = 0, effects = [], defaultContext = {};
const NOOP = () => {
}, STATE_CLEAN = 0, STATE_CHECK = 1, STATE_DIRTY = 2, STATE_DISPOSED = 3;
function flushEffects() {
  scheduledEffects = true;
  queueMicrotask(runEffects);
}
function runEffects() {
  if (!effects.length) {
    scheduledEffects = false;
    return;
  }
  runningEffects = true;
  for (let i = 0; i < effects.length; i++) {
    if (effects[i]._state !== STATE_CLEAN)
      runTop(effects[i]);
  }
  effects = [];
  scheduledEffects = false;
  runningEffects = false;
}
function runTop(node) {
  let ancestors = [node];
  while (node = node[SCOPE]) {
    if (node._effect && node._state !== STATE_CLEAN)
      ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    updateCheck(ancestors[i]);
  }
}
function root(init) {
  const scope = createScope();
  return compute(scope, !init.length ? init : init.bind(null, dispose.bind(scope)), null);
}
function peek(fn) {
  return compute(currentScope, fn, null);
}
function untrack(fn) {
  return compute(null, fn, null);
}
function tick() {
  if (!runningEffects)
    runEffects();
}
function getScope() {
  return currentScope;
}
function scoped(run, scope) {
  try {
    return compute(scope, run, null);
  } catch (error) {
    handleError(scope, error);
    return;
  }
}
function getContext(key, scope = currentScope) {
  return scope?._context[key];
}
function setContext(key, value, scope = currentScope) {
  if (scope)
    scope._context = { ...scope._context, [key]: value };
}
function onError(handler) {
  if (!currentScope)
    return;
  currentScope._handlers = currentScope._handlers ? [handler, ...currentScope._handlers] : [handler];
}
function onDispose(disposable) {
  if (!disposable || !currentScope)
    return disposable || NOOP;
  const node = currentScope;
  if (!node._disposal) {
    node._disposal = disposable;
  } else if (Array.isArray(node._disposal)) {
    node._disposal.push(disposable);
  } else {
    node._disposal = [node._disposal, disposable];
  }
  return function removeDispose() {
    if (node._state === STATE_DISPOSED)
      return;
    disposable.call(null);
    if (isFunction$1(node._disposal)) {
      node._disposal = null;
    } else if (Array.isArray(node._disposal)) {
      node._disposal.splice(node._disposal.indexOf(disposable), 1);
    }
  };
}
function dispose(self = true) {
  if (this._state === STATE_DISPOSED)
    return;
  if (this._children) {
    if (Array.isArray(this._children)) {
      for (let i = this._children.length - 1; i >= 0; i--) {
        dispose.call(this._children[i]);
      }
    } else {
      dispose.call(this._children);
    }
  }
  if (self) {
    const parent = this[SCOPE];
    if (parent) {
      if (Array.isArray(parent._children)) {
        parent._children.splice(parent._children.indexOf(this), 1);
      } else {
        parent._children = null;
      }
    }
    disposeNode(this);
  }
}
function disposeNode(node) {
  node._state = STATE_DISPOSED;
  if (node._disposal)
    emptyDisposal(node);
  if (node._sources)
    removeSourceObservers(node, 0);
  node[SCOPE] = null;
  node._sources = null;
  node._observers = null;
  node._children = null;
  node._context = defaultContext;
  node._handlers = null;
}
function emptyDisposal(scope) {
  try {
    if (Array.isArray(scope._disposal)) {
      for (let i = scope._disposal.length - 1; i >= 0; i--) {
        const callable = scope._disposal[i];
        callable.call(callable);
      }
    } else {
      scope._disposal.call(scope._disposal);
    }
    scope._disposal = null;
  } catch (error) {
    handleError(scope, error);
  }
}
function compute(scope, compute2, observer) {
  const prevScope = currentScope, prevObserver = currentObserver;
  currentScope = scope;
  currentObserver = observer;
  try {
    return compute2.call(scope);
  } finally {
    currentScope = prevScope;
    currentObserver = prevObserver;
  }
}
function handleError(scope, error) {
  if (!scope || !scope._handlers)
    throw error;
  let i = 0, len = scope._handlers.length, currentError = error;
  for (i = 0; i < len; i++) {
    try {
      scope._handlers[i](currentError);
      break;
    } catch (error2) {
      currentError = error2;
    }
  }
  if (i === len)
    throw currentError;
}
function read() {
  if (this._state === STATE_DISPOSED)
    return this._value;
  if (currentObserver && !this._effect) {
    if (!currentObservers && currentObserver._sources && currentObserver._sources[currentObserversIndex] == this) {
      currentObserversIndex++;
    } else if (!currentObservers)
      currentObservers = [this];
    else
      currentObservers.push(this);
  }
  if (this._compute)
    updateCheck(this);
  return this._value;
}
function write(newValue) {
  const value = isFunction$1(newValue) ? newValue(this._value) : newValue;
  if (this._changed(this._value, value)) {
    this._value = value;
    if (this._observers) {
      for (let i = 0; i < this._observers.length; i++) {
        notify(this._observers[i], STATE_DIRTY);
      }
    }
  }
  return this._value;
}
const ScopeNode = function Scope() {
  this[SCOPE] = null;
  this._children = null;
  if (currentScope)
    currentScope.append(this);
};
const ScopeProto = ScopeNode.prototype;
ScopeProto._context = defaultContext;
ScopeProto._handlers = null;
ScopeProto._compute = null;
ScopeProto._disposal = null;
ScopeProto.append = function(child) {
  child[SCOPE] = this;
  if (!this._children) {
    this._children = child;
  } else if (Array.isArray(this._children)) {
    this._children.push(child);
  } else {
    this._children = [this._children, child];
  }
  child._context = child._context === defaultContext ? this._context : { ...this._context, ...child._context };
  if (this._handlers) {
    child._handlers = !child._handlers ? this._handlers : [...child._handlers, ...this._handlers];
  }
};
ScopeProto.dispose = function() {
  dispose.call(this);
};
function createScope() {
  return new ScopeNode();
}
const ComputeNode = function Computation(initialValue, compute2, options) {
  ScopeNode.call(this);
  this._state = compute2 ? STATE_DIRTY : STATE_CLEAN;
  this._init = false;
  this._effect = false;
  this._sources = null;
  this._observers = null;
  this._value = initialValue;
  this.id = options?.id ?? (this._compute ? "computed" : "signal");
  if (compute2)
    this._compute = compute2;
  if (options && options.dirty)
    this._changed = options.dirty;
};
const ComputeProto = ComputeNode.prototype;
Object.setPrototypeOf(ComputeProto, ScopeProto);
ComputeProto._changed = isNotEqual;
ComputeProto.call = read;
function createComputation(initialValue, compute2, options) {
  return new ComputeNode(initialValue, compute2, options);
}
function isNotEqual(a, b) {
  return a !== b;
}
function isFunction$1(value) {
  return typeof value === "function";
}
function updateCheck(node) {
  if (node._state === STATE_CHECK) {
    for (let i = 0; i < node._sources.length; i++) {
      updateCheck(node._sources[i]);
      if (node._state === STATE_DIRTY) {
        break;
      }
    }
  }
  if (node._state === STATE_DIRTY)
    update(node);
  else
    node._state = STATE_CLEAN;
}
function cleanup(node) {
  if (node._children)
    dispose.call(node, false);
  if (node._disposal)
    emptyDisposal(node);
  node._handlers = node[SCOPE] ? node[SCOPE]._handlers : null;
}
function update(node) {
  let prevObservers = currentObservers, prevObserversIndex = currentObserversIndex;
  currentObservers = null;
  currentObserversIndex = 0;
  try {
    cleanup(node);
    const result = compute(node, node._compute, node);
    updateObservers(node);
    if (!node._effect && node._init) {
      write.call(node, result);
    } else {
      node._value = result;
      node._init = true;
    }
  } catch (error) {
    if (!node._init && typeof node._value === "undefined") {
      console.error(
        `computed \`${node.id}\` threw error during first run, this can be fatal.

Solutions:

1. Set the \`initial\` option to silence this error`,
        "\n2. Or, use an `effect` if the return value is not being used",
        "\n\n",
        error
      );
    }
    updateObservers(node);
    handleError(node, error);
  } finally {
    currentObservers = prevObservers;
    currentObserversIndex = prevObserversIndex;
    node._state = STATE_CLEAN;
  }
}
function updateObservers(node) {
  if (currentObservers) {
    if (node._sources)
      removeSourceObservers(node, currentObserversIndex);
    if (node._sources && currentObserversIndex > 0) {
      node._sources.length = currentObserversIndex + currentObservers.length;
      for (let i = 0; i < currentObservers.length; i++) {
        node._sources[currentObserversIndex + i] = currentObservers[i];
      }
    } else {
      node._sources = currentObservers;
    }
    let source;
    for (let i = currentObserversIndex; i < node._sources.length; i++) {
      source = node._sources[i];
      if (!source._observers)
        source._observers = [node];
      else
        source._observers.push(node);
    }
  } else if (node._sources && currentObserversIndex < node._sources.length) {
    removeSourceObservers(node, currentObserversIndex);
    node._sources.length = currentObserversIndex;
  }
}
function notify(node, state) {
  if (node._state >= state)
    return;
  if (node._effect && node._state === STATE_CLEAN) {
    effects.push(node);
    if (!scheduledEffects)
      flushEffects();
  }
  node._state = state;
  if (node._observers) {
    for (let i = 0; i < node._observers.length; i++) {
      notify(node._observers[i], STATE_CHECK);
    }
  }
}
function removeSourceObservers(node, index) {
  let source, swap;
  for (let i = index; i < node._sources.length; i++) {
    source = node._sources[i];
    if (source._observers) {
      swap = source._observers.indexOf(node);
      source._observers[swap] = source._observers[source._observers.length - 1];
      source._observers.pop();
    }
  }
}

function signal(initialValue, options) {
  const node = createComputation(initialValue, null, options), signal2 = read.bind(node);
  signal2.node = node;
  signal2[SCOPE] = true;
  signal2.set = write.bind(node);
  return signal2;
}
function isReadSignal(fn) {
  return isFunction$1(fn) && SCOPE in fn;
}
function computed(compute, options) {
  const node = createComputation(
    options?.initial,
    compute,
    options
  ), signal2 = read.bind(node);
  signal2[SCOPE] = true;
  signal2.node = node;
  return signal2;
}
function effect$1(effect2, options) {
  const signal2 = createComputation(
    null,
    function runEffect() {
      let effectResult = effect2();
      isFunction$1(effectResult) && onDispose(effectResult);
      return null;
    },
    { id: options?.id ?? "effect" } 
  );
  signal2._effect = true;
  update(signal2);
  {
    return function stopEffect() {
      dispose.call(signal2, true);
    };
  }
}
function readonly(signal2) {
  const readonly2 = () => signal2();
  readonly2[SCOPE] = true;
  readonly2.node = signal2.node;
  return readonly2;
}
function isWriteSignal(fn) {
  return isReadSignal(fn) && "set" in fn;
}

function noop(...args) {}

function isNull(value) {
  return value === null;
}

function isUndefined(value) {
  return typeof value === 'undefined';
}

function isNil(value) {
  return isNull(value) || isUndefined(value);
}

function isObject(value) {
  return value?.constructor === Object;
}

function isNumber(value) {
  return typeof value === 'number' && !Number.isNaN(value);
}

function isString(value) {
  return typeof value === 'string';
}

function isBoolean(value) {
  return typeof value === 'boolean';
}

function isFunction(value) {
  return typeof value === 'function';
}

function isArray(value) {
  return Array.isArray(value);
}

function createRegex(regex) {
  return isString(regex) ? new RegExp(regex) : regex;
}

function isWindow(value) {
  if (IS_SERVER) return false;
  return value === window;
}

/**
 * Invokes the given function each time any of the signals that are read inside are updated
 * (i.e., their value changes). The effect is immediately invoked on initialization.
 *
 * @see {@link https://github.com/maverick-js/signals#effect}
 */
const effect = (IS_SERVER ? serverEffect : effect$1) ;

function serverEffect(effect, options) {
  if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'test') {
    return effect$1(effect, options);
  }

  return noop;
}

const EVENT = IS_SERVER ? (class Event {} ) : Event,
  DOM_EVENT = Symbol('DOM_EVENT');






class DOMEvent extends EVENT {
  [DOM_EVENT] = true;

  /**
   * The event detail.
   */
   detail;

  /**
   * The event trigger chain.
   */
   triggers = new EventTriggers();

  /**
   * The preceding event that was responsible for this event being fired.
   */
  get trigger() {
    return this.triggers.source;
  }

  /**
   * The origin event that lead to this event being fired.
   */
  get originEvent() {
    return this.triggers.origin;
  }

  /**
   * Whether the origin event was triggered by the user.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted}
   */
  get isOriginTrusted() {
    return this.triggers.origin?.isTrusted ?? false;
  }

  constructor(
    type,
    ...init


  ) {
    super(type, init[0]);
    this.detail = init[0]?.detail;

    const trigger = init[0]?.trigger;
    if (trigger) this.triggers.add(trigger);
  }
}

class EventTriggers  {
   chain = [];

  get source() {
    return this.chain[0];
  }

  get origin() {
    return this.chain[this.chain.length - 1];
  }

  /**
   * Appends the event to the end of the chain.
   */
  add(event) {
    this.chain.push(event);
    if (isDOMEvent(event)) {
      this.chain.push(...event.triggers);
    }
  }

  /**
   * Removes the event from the chain and returns it (if found).
   */
  remove(event) {
    return this.chain.splice(this.chain.indexOf(event), 1)[0];
  }

  /**
   * Returns whether the chain contains the given `event`.
   */
  has(event) {
    return this.chain.some((e) => e === event);
  }

  /**
   * Returns whether the chain contains the given event type.
   */
  hasType(type) {
    return !!this.findType(type);
  }

  /**
   * Returns the first event with the given `type` found in the chain.
   */
  findType(type) {
    return this.chain.find((e) => e.type === type);
  }

  /**
   * Walks an event chain on a given `event`, and invokes the given `callback` for each trigger event.
   */
  walk(
    callback,
  ) {
    for (const event of this.chain) {
      const returnValue = callback(event);
      if (returnValue) return [event, returnValue];
    }
  }

  [Symbol.iterator]() {
    return this.chain.values();
  }
}

/**
 * Whether the given `event` is a `DOMEvent` class.
 */
function isDOMEvent(event) {
  return !!event?.[DOM_EVENT];
}

/**
 * Walks up the event chain (following each `trigger`) and returns the origin event that
 * started the chain.
 * @deprecated - Use `event.originEvent`
 */
function getOriginEvent(event) {
  return event.originEvent;
}

/**
 * Walks an event chain on a given `event`, and invokes the given `callback` for each trigger event.
 * @deprecated - Use `event.triggers.walk(callback)`
 */
function walkTriggerEventChain(
  event,
  callback,
) {
  if (!isDOMEvent(event)) return;
  return event.triggers.walk(callback);
}

/**
 * Attempts to find a trigger event with a given `eventType` on the event chain.
 * @deprecated - Use `event.triggers.findType('')`
 */
function findTriggerEvent(event, type) {
  return isDOMEvent(event) ? event.triggers.findType(type) : undefined;
}

/**
 * Whether a trigger event with the given `eventType` exists can be found in the event chain.
 * @deprecated - Use `event.triggers.hasType('')`
 */
function hasTriggerEvent(event, type) {
  return !!findTriggerEvent(event, type);
}

/**
 * Appends the given `trigger` to the event chain.
 * @deprecated - Use `event.triggers.add(event)`
 */
function appendTriggerEvent(event, trigger) {
  if (trigger) event.triggers.add(trigger);
}






















class EventsTarget extends EventTarget {
  /** @internal type only */
  $ts__events;
   addEventListener(
    type,
    callback,
    options,
  ) {
    return super.addEventListener(type , callback , options);
  }
   removeEventListener(
    type,
    callback,
    options,
  ) {
    return super.removeEventListener(type , callback , options);
  }
}

















/**
 * Adds an event listener for the given `type` and returns a function which can be invoked to
 * remove the event listener.
 *
 * - The listener is removed if the current scope is disposed.
 * - This function is safe to use on the server (noop).
 */
function listenEvent



(
  target,
  type,
  handler,
  options,
) {
  if (IS_SERVER) return noop;
  target.addEventListener(type, handler , options);
  return onDispose(() => target.removeEventListener(type, handler , options));
}

class EventsController {
  #target;
  #controller;

  get signal() {
    return this.#controller.signal;
  }

  constructor(target) {
    this.#target = target;
    this.#controller = new AbortController();
    onDispose(this.abort.bind(this));
  }

  add(
    type,
    handler,
    options,
  ) {
    if (this.signal.aborted) throw Error('aborted');

    this.#target.addEventListener(type , handler , {
      ...options,
      signal: options?.signal ? anySignal(this.signal, options.signal) : this.signal,
    });

    return this;
  }

  remove(
    type,
    handler,
  ) {
    this.#target.removeEventListener(type , handler );
    return this;
  }

  abort(reason) {
    this.#controller.abort(reason);
  }
}

/**
 * Returns an `AbortSignal` that will abort when any of the given signals are aborted.
 */
function anySignal(...signals) {
  const controller = new AbortController(),
    options = { signal: controller.signal };

  function onAbort(event) {
    controller.abort((event.target ).reason);
  }

  for (const signal of signals) {
    if (signal.aborted) {
      controller.abort(signal.reason);
      break;
    }

    signal.addEventListener('abort', onAbort, options);
  }

  return controller.signal;
}

function isPointerEvent(event) {
  return !!event?.type.startsWith('pointer');
}

function isTouchEvent(event) {
  return !!event?.type.startsWith('touch');
}

function isMouseEvent(event) {
  return /^(click|mouse)/.test(event?.type ?? '');
}

function isKeyboardEvent(event) {
  return !!event?.type.startsWith('key');
}

function wasEnterKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === 'Enter';
}

function wasEscapeKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === 'Escape';
}

function isKeyboardClick(event) {
  return isKeyboardEvent(event) && (event.key === 'Enter' || event.key === ' ');
}

function isDOMNode(node) {
  return node instanceof Node;
}

function isDOMElement(node) {
  return isDOMNode(node) && node.nodeType === 1;
}

function isDOMFragment(node) {
  return isDOMNode(node) && node.nodeType === 11;
}

function createFragment() {
  return document.createDocumentFragment();
}

function createComment(data) {
  if (IS_SERVER) return data ;
  return document.createComment(data);
}

/**
 * Sets or removes the given attribute `value`. Falsy values except `''` and `0` will remove
 * the attribute. If the given `value` is a function/signal, the attribute will be updated as
 * the value updates.
 *
 * This function is safe to use on the server.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Falsy}
 */
function setAttribute(
  host,
  name,
  value,
) {
  if (!host) return;
  else if (!value && value !== '' && value !== 0) {
    host.removeAttribute(name);
  } else {
    const attrValue = value === true ? '' : value + '';
    if (host.getAttribute(name) !== attrValue) {
      host.setAttribute(name, attrValue);
    }
  }
}

/**
 * Sets or removes the given style `value`. Falsy values will remove the style. If the
 * given `value` is a function/signal, the style will be updated as the value updates.
 *
 * This function is safe to use on the server.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Falsy}
 */
function setStyle(
  host,
  property,
  value,
) {
  if (!host) return;
  else if (!value && value !== 0) {
    host.style.removeProperty(property);
  } else {
    host.style.setProperty(property, value + '');
  }
}

/**
 * Toggles the given class `name`. Falsy values will remove the class from the list. If the
 * given `value` is a function/signal, the class will be toggled as the value updates.
 *
 * This function is safe to use on the server.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Falsy}
 */
function toggleClass(host, name, value) {
  host.classList[value ? 'add' : 'remove'](name);
}

/**
 * Returns elements assigned to the given slot in the shadow root. Filters out all nodes
 * which are not an element.
 *
 * @param el - The element containing the slot.
 * @param name - The name of the slot (optional).
 */
function getSlottedChildren(el, name) {
  const selector = name ? `slot[name="${name}"]` : 'slot:not([name])';
  const slot = el.shadowRoot?.querySelector(selector) ;
  const childNodes = slot?.assignedNodes({ flatten: true }) ?? [];
  return Array.prototype.filter.call(childNodes, (node) => node.nodeType == 1);
}

function attachDeclarativeShadowDOM(element) {
  const template = element.firstChild ;
  const mode = template.getAttribute('shadowroot') ;
  const shadowRoot = (template.parentNode ).attachShadow({ mode });
  shadowRoot.appendChild(template.content);
  template.remove();
}

/**
 * Unwraps possible function calls and returns the value. It will return the value if the given
 * argument is not a function.
 */
function unwrap(fn) {
  return isFunction(fn) ? fn() : fn;
}

/**
 * Recursively unwraps possible function calls and returns the final value. It will return
 * the value if the given argument is not a function.
 */
function unwrapDeep( fn) {
  let value = fn;
  while (typeof value === 'function') value = value.call(this);
  return value;
}

function createContext(provide) {
  return { id: Symbol(), provide };
}

function provideContext(context, value, scope = getScope()) {
  if (!scope) {
    throw Error('[maverick] attempting to provide context outside root');
  }

  const hasProvidedValue = !isUndefined(value);

  if (!hasProvidedValue && !context.provide) {
    throw Error('[maverick] context can not be provided without a value or `provide` function');
  }

  setContext(context.id, hasProvidedValue ? value : context.provide?.(), scope);
}

function useContext(context) {
  const value = getContext(context.id) ;

  if (isUndefined(value)) {
    throw Error('[maverick] attempting to use context without providing first');
  }

  return value;
}

function hasProvidedContext(context) {
  return !isUndefined(getContext(context.id));
}

const PROPS = /* #__PURE__ */ Symbol('PROPS' );
const METHODS = /* #__PURE__ */ Symbol('METHODS' );
const ON_DISPATCH = /* #__PURE__ */ Symbol('ON_DISPATCH' );

const EMPTY_PROPS = {} ;



class Instance {
  /** @internal type only */
  $ts__events;
  /** @internal type only */
  $ts__vars;

  /* @internal */
  [ON_DISPATCH] = null;

   $el = signal(null);

  el = null;
  scope = null;
  attachScope = null;
  connectScope = null;
  component = null;
  destroyed = false;

  props = EMPTY_PROPS;
  attrs = null;
  styles = null;

  state;
  $state;

  #setupCallbacks = [];
  #attachCallbacks = [];
  #connectCallbacks = [];
  #destroyCallbacks = [];

  constructor(
    Component,
    scope,
    init,
  ) {
    this.scope = scope;
    if (init?.scope) init.scope.append(scope);

    let stateFactory = Component.state,
      props = Component.props;

    if (stateFactory) {
      this.$state = stateFactory.create();
      this.state = new Proxy(this.$state, {
        get: (_, prop) => this.$state[prop](),
      }) ;
      provideContext(stateFactory, this.$state);
    }

    if (props) {
      this.props = createInstanceProps(props) ;
      if (init?.props) {
        for (const prop of Object.keys(init.props)) {
          this.props[prop]?.set(init.props[prop]);
        }
      }
    }

    onDispose(this.destroy.bind(this));
  }

  setup() {
    scoped(() => {
      for (const callback of this.#setupCallbacks) callback();
    }, this.scope);
  }

  attach(el) {
    if (this.el) return;

    this.el = el ;
    this.$el.set(el );

    {
      (el ).$$COMPONENT_NAME = this.component?.constructor.name;
    }

    scoped(() => {
      this.attachScope = createScope();
      scoped(() => {
        for (const callback of this.#attachCallbacks) callback(this.el);
        this.#attachAttrs();
        this.#attachStyles();
      }, this.attachScope);
    }, this.scope);

    el.dispatchEvent(new Event('attached'));
  }

  detach() {
    this.attachScope?.dispose();
    this.attachScope = null;
    this.connectScope = null;

    if (this.el) {
      (this.el ).$$COMPONENT_NAME = null;
    }

    this.el = null;
    this.$el.set(null);
  }

  connect() {
    if (!this.el || !this.attachScope || !this.#connectCallbacks.length) return;
    scoped(() => {
      this.connectScope = createScope();
      scoped(() => {
        for (const callback of this.#connectCallbacks) callback(this.el);
      }, this.connectScope);
    }, this.attachScope);
  }

  disconnect() {
    this.connectScope?.dispose();
    this.connectScope = null;
  }

  destroy() {
    if (this.destroyed) return;
    this.destroyed = true;

    scoped(() => {
      for (const callback of this.#destroyCallbacks) callback(this.el);
    }, this.scope);

    const el = this.el;

    this.detach();
    this.scope.dispose();

    this.#setupCallbacks.length = 0;
    this.#attachCallbacks.length = 0;
    this.#connectCallbacks.length = 0;
    this.#destroyCallbacks.length = 0;

    this.component = null;
    this.attrs = null;
    this.styles = null;
    this.props = EMPTY_PROPS;
    this.scope = null;
    this.state = EMPTY_PROPS;
    this.$state = null;
    // @ts-expect-error
    if (el) delete el.$;
  }

  addHooks(target) {
    if (target.onSetup) this.#setupCallbacks.push(target.onSetup.bind(target));
    if (target.onAttach) this.#attachCallbacks.push(target.onAttach.bind(target));
    if (target.onConnect) this.#connectCallbacks.push(target.onConnect.bind(target));
    if (target.onDestroy) this.#destroyCallbacks.push(target.onDestroy.bind(target));
  }

  #attachAttrs() {
    if (!this.attrs) return;
    for (const name of Object.keys(this.attrs)) {
      if (IS_SERVER) {
        setAttribute(this.el, name, unwrapDeep.call(this.component, this.attrs[name]));
      } else if (isFunction(this.attrs[name])) {
        effect(this.#setAttr.bind(this, name));
      } else {
        setAttribute(this.el, name, this.attrs[name]);
      }
    }
  }

  #attachStyles() {
    if (!this.styles) return;
    for (const name of Object.keys(this.styles)) {
      if (IS_SERVER) {
        setStyle(this.el, name, unwrapDeep.call(this.component, this.styles[name]));
      } else if (isFunction(this.styles[name])) {
        effect(this.#setStyle.bind(this, name));
      } else {
        setStyle(this.el, name, this.styles[name]);
      }
    }
  }

  #setAttr(name) {
    setAttribute(this.el, name, (this.attrs[name] ).call(this.component));
  }

  #setStyle(name) {
    setStyle(this.el, name, (this.styles[name] ).call(this.component));
  }
}

function createInstanceProps(props) {
  const $props = {} ;

  for (const name of Object.keys(props )) {
    const def = props[name];
    $props[name] = signal(def, def);
  }

  return $props;
}

// Match component interface.
let currentInstance = { $$: null };

function createComponent(
  Component,
  init,
) {
  return root(() => {
    currentInstance.$$ = new Instance(Component, getScope(), init);
    const component = new Component();
    currentInstance.$$.component = component;
    currentInstance.$$ = null;
    return component;
  });
}

class ViewController extends EventTarget {
  /** @internal */
  $$;

  get el() {
    return this.$$.el;
  }

  get $el() {
    return this.$$.$el();
  }

  get scope() {
    return this.$$.scope;
  }

  get attachScope() {
    return this.$$.attachScope;
  }

  get connectScope() {
    return this.$$.connectScope;
  }

  /** @internal */
  get $props() {
    return this.$$.props;
  }

  /** @internal */
  get $state() {
    return this.$$.$state;
  }

  get state() {
    return this.$$.state;
  }

  constructor() {
    super();
    if (currentInstance.$$) this.attach(currentInstance );
  }

  attach({ $$ }) {
    this.$$ = $$;
    $$.addHooks(this );
    return this;
  }

   addEventListener(
    type,
    callback,
    options,
  ) {
    if (!this.el) {
      const name = this.constructor.name;
      console.warn(`[maverick] adding event listener to \`${name}\` before element is attached`);
    }

    this.listen(type , callback , options);
  }

   removeEventListener(
    type,
    callback,
    options,
  ) {
    this.el?.removeEventListener(type, callback , options);
  }

  /**
   * The given callback is invoked when the component is ready to be set up.
   *
   * - This hook will run once.
   * - This hook is called both client-side and server-side.
   * - It's safe to use context inside this hook.
   * - The host element has not attached yet - wait for `onAttach`.
   */
  



























  /**
   * This method can be used to specify attributes that should be set on the host element. Any
   * attributes that are assigned to a function will be considered a signal and updated accordingly.
   */
   setAttributes(attributes) {
    if (!this.$$.attrs) this.$$.attrs = {};
    Object.assign(this.$$.attrs, attributes);
  }

  /**
   * This method can be used to specify styles that should set be set on the host element. Any
   * styles that are assigned to a function will be considered a signal and updated accordingly.
   */
   setStyles(styles) {
    if (!this.$$.styles) this.$$.styles = {};
    Object.assign(this.$$.styles, styles);
  }

  /**
   * This method is used to satisfy the CSS variables contract specified on the current
   * component. Other CSS variables can be set via the `setStyles` method.
   */
   setCSSVars(vars) {
    this.setStyles(vars );
  }

  /**
   * Type-safe utility for creating component DOM events.
   */
  createEvent(
    type,
    ...init




  ) {
    return new DOMEvent(type, init[0] ) ;
  }

  /**
   * Creates a `DOMEvent` and dispatches it from the host element. This method is typed to
   * match all component events.
   */
  dispatch(
    type,
    ...init








  ) {
    if (IS_SERVER || !this.el) return false;

    const event =
      type instanceof Event ? type : new DOMEvent(type , init[0] );

    Object.defineProperty(event, 'target', {
      get: () => this.$$.component,
    });

    return untrack(() => {
      this.$$[ON_DISPATCH]?.(event);
      return this.el.dispatchEvent(event);
    });
  }

   dispatchEvent(event) {
    return this.dispatch(event);
  }

  /**
   * Adds an event listener for the given `type` and returns a function which can be invoked to
   * remove the event listener.
   *
   * - The listener is removed if the current scope is disposed.
   * - This method is safe to use on the server (noop).
   */
  listen(
    type,
    handler,
    options,
  ) {
    if (IS_SERVER || !this.el) return noop;
    return listenEvent(this.el, type , handler, options);
  }
}

class Component extends ViewController




 {
  subscribe(callback) {
    if (!this.state) {
      const name = this.constructor.name;
      throw Error(
        `[maverick] component \`${name}\` can not be subscribed to because it has no internal state`,
      );
    }

    return scoped(() => effect(() => callback(this.state)), this.$$.scope);
  }

  destroy() {
    this.$$.destroy();
  }
}

function prop(target, propertyKey, descriptor) {
  if (!target[PROPS]) target[PROPS] = new Set();
  target[PROPS].add(propertyKey);
}

function method(
  target,
  propertyKey,
  descriptor,
) {
  if (!target[METHODS]) target[METHODS] = new Set();
  target[METHODS].add(propertyKey);
}

/**
 * Converts objects into signals. The factory stores the initial object and enables producing new
 * objects where each value in the provided object becomes a signal.
 *
 * @example
 * ```ts
 * const factory = new State({
 *   foo: 0,
 *   bar: '...',
 *   get baz() {
 *     return this.foo + 1;
 *   }
 * });
 *
 * console.log(factory.record); // logs `{ foo: 0, bar: '...' }`
 *
 * const $state = factory.create();
 *
 * effect(() => console.log($state.foo()));
 * // Run effect ^
 * $state.foo.set(1);
 *
 * // Reset all values
 * factory.reset($state);
 * ```
 */
class State {
   id = Symbol('STATE' );
   record;

  #descriptors

;

  constructor(record) {
    this.record = record;
    this.#descriptors = Object.getOwnPropertyDescriptors(record);
  }

  create() {
    const store = {} ,
      state = new Proxy(store, { get: (_, prop) => store[prop]() });

    for (const name of Object.keys(this.record) ) {
      const getter = this.#descriptors[name].get;
      store[name] = getter ? computed(getter.bind(state)) : signal(this.record[name]);
    }

    return store;
  }

  reset(record, filter) {
    for (const name of Object.keys(record) ) {
      if (!this.#descriptors[name].get && (!filter || filter(name))) {
        (record[name] ).set(this.record[name]);
      }
    }
  }
}





















/**
 * Returns the state record context value for the current component tree.
 */
function useState(state) {
  return useContext(state);
}

/**
 * Converts a camelCase string to kebab-case.
 *
 * @example `myProperty -> my-property`
 */
function camelToKebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

/**
 * Converts a camelCase string to Title Case.
 *
 * @example `myProperty -> Title Case`
 */
function camelToTitleCase(str) {
  return uppercaseFirstChar(str.replace(/([A-Z])/g, ' $1'));
}

/**
 * Converts a kebab-case string to camelCase.
 *
 * @example `my-property -> myProperty`
 */
function kebabToCamelCase(str) {
  return str.replace(/-./g, (x) => x[1].toUpperCase());
}

/**
 * Converts a kebab-case string to PascalCase.
 *
 * @example `myProperty -> MyProperty`
 */
function kebabToPascalCase(str) {
  return kebabToTitleCase(str).replace(/\s/g, '');
}

/**
 * Converts a kebab-case string to Title Case.
 *
 * @example `myProperty -> My Property`
 */
function kebabToTitleCase(str) {
  return uppercaseFirstChar(str.replace(/-./g, (x) => ' ' + x[1].toUpperCase()));
}

function uppercaseFirstChar(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function lowercaseFirstLetter(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

const trailingSemicolon = /;\s*$/;
function trimTrailingSemicolon(text) {
  return text.replace(trailingSemicolon, '');
}

const ReactScopeContext = React.createContext({ current: null });
ReactScopeContext.displayName = 'Scope';

function WithScope(scope, ...children) {
  return React.createElement(ReactScopeContext.Provider, { value: scope }, ...children);
}

function useReactScope() {
  return React.useContext(ReactScopeContext).current;
}

function useReactContext(context) {
  const scope = useReactScope();
  return React.useMemo(() => getContext(context.id, scope), [scope]);
}

function createReactScopeProvider() {
  return ScopeProvider;
}

function createReactContextProvider(
  context,
  provide,
) {
  return class ContextProvider extends ScopeProvider {
    static  #context = context;
    static  #provide = provide;
  };
}

class ScopeProvider extends React.Component {
  static  contextType = ReactScopeContext;
  ;

  static #context;
  static #provide;

  #scope;

  constructor(props, context) {
    super(props);

    this.#scope = {
      current: createScope(),
    };

    if (context) context.append(this.#scope.current);

    const Ctor = this.constructor ;
    if (Ctor.#context) provideContext(Ctor.#context, Ctor.#provide?.(), this.#scope.current);
  }

   render() {
    return WithScope(this.#scope, this.props?.children);
  }
}

function setRef(ref, value) {
  if (typeof ref === 'function') {
    (ref )(value);
  } else if (ref) {
    (ref ).current = value;
  }
}



function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}

function createClientComponent(
  Component,
  options,
) {
  const forwardComponent = React.forwardRef((props, forwardRef) => {
    let parentScopeRef = React.useContext(ReactScopeContext),
      scopeRef = React.useRef(null),
      stateRef = React.useRef();

    if (!stateRef.current) {
      const state = createInternalState(),
        component = initComponent(Component, state, props, parentScopeRef.current);

      state.component = component;

      stateRef.current = state;
      scopeRef.current = component.scope;
    }

    function onAttach() {
      let state = stateRef.current,
        scope = parentScopeRef.current;

      window.cancelAnimationFrame(state.destroyId);
      state.destroyId = -1;

      if (state.component.$$.destroyed) {
        const component = initComponent(Component, state, props, scope);
        state.component = component;
        state.attached = false;
        state.forwardRef = false;
        scopeRef.current = component.scope;
      }

      if (state.el) {
        attachToHost(state, state.el);
      }

      if (!state.forwardRef) {
        setRef(forwardRef, state.component);
        state.forwardRef = true;
      }

      return () => detachFromHost(state);
    }

    function onRefChange(el) {
      const state = stateRef.current;

      if (!state.forwardRef) {
        state.el = el;
        return;
      }

      window.cancelAnimationFrame(state.refChangeId);
      state.refChangeId = window.requestAnimationFrame(() => {
        const state = stateRef.current;
        state.refChangeId = -1;

        if (state.el === el) return;

        detachFromHost(state);
        if (el) attachToHost(state, el);

        state.el = el;
      });
    }

    React.useEffect(() => {
      const state = stateRef.current;

      window.cancelAnimationFrame(state.destroyId);
      state.destroyId = -1;

      return function onDestroy() {
        // Headless components will be destroyed by parent scope.
        if (!isFunction(props.children)) return;

        window.cancelAnimationFrame(state.refChangeId);
        state.refChangeId = -1;

        window.cancelAnimationFrame(state.connectId);
        state.connectId = -1;

        window.cancelAnimationFrame(state.destroyId);
        state.destroyId = window.requestAnimationFrame(() => {
          state.destroyId = -1;

          detachFromHost(state);

          state.component.$$.destroy();
          state.component.$$[ON_DISPATCH] = null;

          state.callbacks = {};
          state.domCallbacks = {};

          scopeRef.current = null;
        });
      };
    }, []);

    React.useEffect(tick);

    let state = stateRef.current,
      { children, ...renderProps } = props,
      attrs = {},
      prevPropNames = state.prevProps,
      newPropNames = Object.keys(renderProps);

    state.callbacks = {};

    for (const name of [...prevPropNames, ...newPropNames]) {
      if (options.props.has(name)) {
        state.component.$props[name].set(
          // If the prop was removed we'll use the default value provided on Component creation.
          isUndefined(renderProps[name]) ? Component.props?.[name] : renderProps[name],
        );
      } else if (options.events?.has(name) || options.eventsRE?.test(name)) {
        state.callbacks[name] = renderProps[name];
      } else if (options.domEvents?.has(name) || options.domEventsRE?.test(name)) {
        let type = camelToKebabCase(name.slice(2));
        state.domCallbacks[type] = renderProps[name];
        if (!newPropNames.includes(name)) {
          state.el?.removeEventListener(type, state.onDOMEvent);
          state.listening?.delete(type);
        } else if (state.el && !state.listening?.has(type)) {
          if (!state.listening) state.listening = new Set();
          state.listening.add(type);
          state.el.addEventListener(type, state.onDOMEvent);
        }
      } else {
        attrs[name] = renderProps[name];
      }
    }

    state.prevProps = newPropNames;

    return WithScope(
      scopeRef,
      React.createElement(AttachEffect, {
        effect: onAttach,
      }),
      isFunction(children)
        ? children?.(
            {
              ...attrs,
              suppressHydrationWarning: true,
              ref: onRefChange,
            },
            state.component,
          )
        : children,
    );
  });

  forwardComponent.displayName = Component.name + 'Bridge';
  return forwardComponent;
}

// Run effects in top-down order.
function AttachEffect({ effect }) {
  React.useEffect(effect, []);
  return null;
}
















const eventTypeToCallbackName = new Map();

function createInternalState() {
  const state = {
    el: null,
    prevProps: [],
    callbacks: {},
    domCallbacks: {},
    refChangeId: -1,
    connectId: -1,
    destroyId: -1,
    attached: false,
    forwardRef: false,
    listening: null,
    onDOMEvent(event) {
      const args = !isUndefined((event ).detail)
        ? [(event ).detail, event]
        : [event];

      state.domCallbacks[event.type]?.(...args);
    },
  };

  return state ;
}

function attachToHost(state, el) {
  if (state.el === el && state.attached) return;
  else if (state.attached) detachFromHost(state);

  if (state.domCallbacks) {
    if (!state.listening) state.listening = new Set();
    for (const type of Object.keys(state.domCallbacks)) {
      if (state.listening.has(type)) continue;
      el.addEventListener(type, state.onDOMEvent);
      state.listening.add(type);
    }
  }

  state.component.$$.attach(el);

  state.connectId = window.requestAnimationFrame(() => {
    state.component.$$.connect();
    state.connectId = -1;
  });

  state.attached = true;
}

function detachFromHost(state) {
  if (!state.attached) return;

  window.cancelAnimationFrame(state.connectId);

  state.connectId = -1;
  state.component.$$.detach();
  state.attached = false;

  if (state.el && state.listening) {
    for (const type of state.listening) {
      state.el.removeEventListener(type, state.onDOMEvent);
    }

    state.listening.clear();
  }
}

function onDispatch( event) {
  let callbackProp = eventTypeToCallbackName.get(event.type),
    args = !isUndefined((event ).detail)
      ? [(event ).detail, event]
      : [event];

  if (!callbackProp) {
    eventTypeToCallbackName.set(event.type, (callbackProp = `on${kebabToPascalCase(event.type)}`));
  }

  this.callbacks[callbackProp]?.(...args);
}

function initComponent(
  Component,
  state,
  props,
  scope,
) {
  const component = createComponent(Component, { props, scope });
  component.$$[ON_DISPATCH] = onDispatch.bind(state);
  component.$$.setup();
  return component;
}

function escape(value, isAttr = false) {
  const type = typeof value;

  if (type !== 'string') {
    if (!isAttr && type === 'function') return escape(value());
    if (isAttr && type === 'boolean') return value + '';
    return value;
  }

  const delimeter = isAttr ? '"' : '<',
    escapeDelimeter = isAttr ? '&quot;' : '&lt;';

  let iDelimeter = value.indexOf(delimeter),
    isAmpersand = value.indexOf('&');

  if (iDelimeter < 0 && isAmpersand < 0) return value;

  let left = 0,
    out = '';

  while (iDelimeter >= 0 && isAmpersand >= 0) {
    if (iDelimeter < isAmpersand) {
      if (left < iDelimeter) out += value.substring(left, iDelimeter);
      out += escapeDelimeter;
      left = iDelimeter + 1;
      iDelimeter = value.indexOf(delimeter, left);
    } else {
      if (left < isAmpersand) out += value.substring(left, isAmpersand);
      out += '&amp;';
      left = isAmpersand + 1;
      isAmpersand = value.indexOf('&', left);
    }
  }

  if (iDelimeter >= 0) {
    do {
      if (left < iDelimeter) out += value.substring(left, iDelimeter);
      out += escapeDelimeter;
      left = iDelimeter + 1;
      iDelimeter = value.indexOf(delimeter, left);
    } while (iDelimeter >= 0);
  } else
    while (isAmpersand >= 0) {
      if (left < isAmpersand) out += value.substring(left, isAmpersand);
      out += '&amp;';
      left = isAmpersand + 1;
      isAmpersand = value.indexOf('&', left);
    }

  return left < value.length ? out + value.substring(left) : out;
}

const SETUP = /* #__PURE__ */ Symbol('SETUP' );

const classSplitRE = /\s+/;
function parseClassAttr(tokens, attrValue) {
  const classes = attrValue.trim().split(classSplitRE);
  for (const token of classes) tokens.add(token);
}

const styleSplitRE = /\s*:\s*/;
const stylesDelimeterRE = /\s*;\s*/;
function parseStyleAttr(tokens, attrValue) {
  const styles = attrValue.trim().split(stylesDelimeterRE);
  for (let i = 0; i < styles.length; i++) {
    if (styles[i] === '') continue;
    const [name, value] = styles[i].split(styleSplitRE);
    tokens.set(name, value);
  }
}

class MaverickServerElement {
  keepAlive = false;
  forwardKeepAlive = true;

   $;
   attributes = new ServerAttributes();
   style = new ServerStyle();
   classList = new ServerClassList();

  get $props() {
    return this.$.$$.props;
  }

  get $state() {
    return this.$.$$.$state;
  }

  get state() {
    return this.$.state;
  }

  constructor(component) {
    this.$ = component;
  }

  setup() {
    const instance = this.$.$$;
    scoped(() => {
      if (this.hasAttribute('class')) {
        parseClassAttr(this.classList.tokens, this.getAttribute('class'));
      }

      if (this.hasAttribute('style')) {
        parseStyleAttr(this.style.tokens, this.getAttribute('style'));
      }

      instance.setup();
      instance.attach(this);

      if (this.classList.length > 0) {
        this.setAttribute('class', this.classList.toString());
      }

      if (this.style.length > 0) {
        this.setAttribute('style', this.style.toString());
      }

      if (this.keepAlive) {
        this.setAttribute('keep-alive', '');
      }
    }, instance.scope);
  }

  getAttribute(name) {
    return this.attributes.getAttribute(name);
  }

  setAttribute(name, value) {
    this.attributes.setAttribute(name, value);
  }

  hasAttribute(name) {
    return this.attributes.hasAttribute(name);
  }

  removeAttribute(name) {
    return this.attributes.removeAttribute(name);
  }

  [SETUP]() {}
  addEventListener() {}
  removeEventListener() {}

  dispatchEvent() {
    return false;
  }

  subscribe() {
    return noop;
  }

  destroy() {
    this.$.destroy();
  }
}

class ServerAttributes {
  #tokens = new Map();
  get length() {
    return this.#tokens.size;
  }
  get tokens() {
    return this.#tokens;
  }
  getAttribute(name) {
    return this.#tokens.get(name) ?? null;
  }
  hasAttribute(name) {
    return this.#tokens.has(name);
  }
  setAttribute(name, value) {
    this.#tokens.set(name, value + '');
  }
  removeAttribute(name) {
    this.#tokens.delete(name);
  }
  toString() {
    if (this.#tokens.size === 0) return '';
    let result = '';
    for (const [name, value] of this.#tokens) {
      result += ` ${name}="${escape(value, true)}"`;
    }
    return result;
  }
}

class ServerStyle {
  #tokens = new Map();
  get length() {
    return this.#tokens.size;
  }
  get tokens() {
    return this.#tokens;
  }
  getPropertyValue(prop) {
    return this.#tokens.get(prop) ?? '';
  }
  setProperty(prop, value) {
    this.#tokens.set(prop, value ?? '');
  }
  removeProperty(prop) {
    const value = this.#tokens.get(prop);
    this.#tokens.delete(prop);
    return value ?? '';
  }
  toString() {
    if (this.#tokens.size === 0) return '';
    let result = '';
    for (const [name, value] of this.#tokens) {
      result += `${name}: ${value};`;
    }
    return result;
  }
}






















class ServerClassList {
  #tokens = new Set();
  get length() {
    return this.#tokens.size;
  }
  get tokens() {
    return this.#tokens;
  }
  add(...tokens) {
    for (const token of tokens) {
      this.#tokens.add(token);
    }
  }
  contains(token) {
    return this.#tokens.has(token);
  }
  remove(token) {
    this.#tokens.delete(token);
  }
  replace(token, newToken) {
    if (!this.#tokens.has(token)) return false;
    this.#tokens.delete(token);
    this.#tokens.add(newToken);
    return true;
  }
  toggle(token, force) {
    if (force !== true && (this.#tokens.has(token) || force === false)) {
      this.#tokens.delete(token);
      return false;
    } else {
      this.#tokens.add(token);
      return true;
    }
  }
  toString() {
    return Array.from(this.#tokens).join(' ');
  }
}

const attrsToProps = {
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  allowfullscreen: 'allowFullScreen',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  charset: 'charSet',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  colspan: 'colSpan',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controlslist: 'controlsList',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  datetime: 'dateTime',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  disablepictureinpicture: 'disablePictureInPicture',
  disableremoteplayback: 'disableRemotePlayback',
  enctype: 'encType',
  enterkeyhint: 'enterKeyHint',
  fetchpriority: 'fetchPriority',
  for: 'htmlFor',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  imagesizes: 'imageSizes',
  imagesrcset: 'imageSrcSet',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  maxlength: 'maxLength',
  mediagroup: 'mediaGroup',
  minlength: 'minLength',
  nomodule: 'noModule',
  novalidate: 'noValidate',
  playsinline: 'playsInline',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rowspan: 'rowSpan',
  spellcheck: 'spellCheck',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  tabindex: 'tabIndex',
  usemap: 'useMap',
};

function createServerComponent(
  Component,
  options,
) {
  function ServerComponent(props) {
    let scope = React.useContext(ReactScopeContext),
      component = createComponent(Component, {
        props,
        scope: scope.current,
      }),
      host = new MaverickServerElement(component),
      attrs = {},
      { style = {}, children, forwardRef, ...renderProps } = props;

    if (options.props.size) {
      for (const prop of Object.keys(renderProps)) {
        if (!options.props.has(prop)) attrs[prop] = renderProps[prop];
      }
    } else {
      attrs = renderProps;
    }

    host.setup();

    if (host.hasAttribute('style')) {
      for (const [name, value] of host.style.tokens) {
        style[name.startsWith('--') ? name : kebabToCamelCase(name)] = value;
      }

      host.removeAttribute('style');
    }

    for (const [attrName, attrValue] of host.attributes.tokens) {
      const propName = attrsToProps[attrName];
      if (propName) {
        if (!(propName in attrs)) {
          attrs[propName] = attrValue;
        }

        host.removeAttribute(attrName);
      }
    }

    return WithScope(
      { current: component.$$.scope },
      isFunction(children)
        ? children?.(
            {
              ...Object.fromEntries(host.attributes.tokens),
              ...attrs,
              style,
            },
            component,
          )
        : children,
      React.createElement(() => {
        host.destroy();
        return null;
      }),
    );
  }

  ServerComponent.displayName = Component.name + 'Bridge';
  return ServerComponent;
}

function useStateContext(
  state,
) {
  return useReactContext(state) ;
}

function useSignal(signal, key) {
  const [, scheduleReactUpdate] = React.useState();

  React.useEffect(() => {
    return effect$1(() => {
      signal();
      scheduleReactUpdate({});
    });
  }, [key ?? signal]);

  return signal();
}

function ariaBool(value) {
  return value ? 'true' : 'false';
}

// This only exists because array.flat(Infinity) is slow.
function flattenArray(array) {
  const flat = [];

  for (let i = 0; i < array.length; i++) {
    if (isArray(array[i])) {
      flat.push(...flattenArray(array[i] ));
    } else if (array[i] || array[i] === 0) {
      flat.push(array[i] );
    }
  }

  return flat;
}

/**
 * Creates and returns a disposal bin for managing cleanup operations.
 *
 * @example
 * ```ts
 * const bin = createDisposalBin();
 * // Add callbacks
 * bin.add(() => {});
 * bin.add(() => {});
 * // Empty bin by running callbacks
 * bin.empty();
 * ```
 */
function createDisposalBin() {
  const disposal = new Set();
  return {
    add(...callbacks) {
      for (const callback of callbacks) disposal.add(callback);
    },
    empty() {
      for (const callback of disposal) callback();
      disposal.clear();
    },
  };
}

/**
 * Creates and return a `DisposalBin`. This bin is emptied if the parent scope is disposed of.
 */
function useDisposalBin() {
  const disposal = createDisposalBin();
  onDispose(disposal.empty);
  return disposal;
}

function run(fn) {
  return fn();
}

function runAll(fns, arg) {
  for (const fn of fns) fn(arg);
}

function keysOf(obj) {
  return Object.keys(obj ) ;
}



















/**
 * Merges properties of the given `sources` together into a single object. All enumerable properties
 * are merged including values, getters, setters, and methods.
 */
function mergeProperties(...sources) {
  const target = {} ;

  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    if (source) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    }
  }

  return target;
}

/**
 * Creates a new object composed of the picked `source` properties. All enumerable properties
 * are merged including values, getters, setters, and methods.
 */
function pick(source, props) {
  const target = {} ;

  for (const prop of props) {
    Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
  }

  return target;
}

/**
 * The opposite of `pick`; this function creates a new object composed of the `source` properties
 * that are not included in the given `props` argument. All enumerable properties are merged
 * including values, getters, setters, and methods.
 */
function omit(source, props) {
  return pick(
    source,
    keysOf(source).filter((key) => !props.includes(key )),
  );
}

/**
 * Creates an empty Promise and defers resolving/rejecting it.
 */
function deferredPromise()


 {
  let resolve, reject;

  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });

  return { promise, resolve, reject };
}

/**
 * Wraps a promise so it can timeout.
 */
function timedPromise(
  promise,
  timeout,
  timeoutMsg,
) {
  const timer = new Promise((_, reject) => {
    const timerId = setTimeout(() => {
      clearTimeout(timerId);
      reject(timeoutMsg);
    }, timeout);
  });

  return Promise.race([promise, timer]) ;
}

/**
 * Resolves after the given `delay` timeout has passed.
 */
function waitTimeout(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}

/**
 * Requests an animation frame and waits for it to be resolved. This is safe to call server-side,
 * no action will be performed.
 *
 * @param callback - Invoked on the next animation frame.
 */
function waitAnimationFrame(callback) {
  if (IS_SERVER) return Promise.resolve();
  return new Promise((resolve) => {
    window.requestAnimationFrame((time) => {
      callback?.(time);
      resolve();
    });
  });
}

/**
 * Creates a throttled function that only invokes `func` at most once per animation frame. This is
 * a noop server-side.
 *
 * @param func - The function to throttle.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
 */
function animationFrameThrottle(func) {
  if (IS_SERVER) return noop ;

  let id = -1,
    lastArgs;

  function throttle( ...args) {
    lastArgs = args;
    if (id >= 0) return;
    id = window.requestAnimationFrame(() => {
      func.apply(this, lastArgs );
      id = -1;
      lastArgs = undefined;
    });
  }

  return throttle ;
}

const requestIdleCallback = IS_SERVER
  ? noop
  : typeof window !== 'undefined'
  ? 'requestIdleCallback' in window
    ? window.requestIdleCallback
    : (cb) => window.setTimeout(cb, 1)
  : noop;

/**
 * Queues and waits for a function to be called during a browser's idle periods. This enables
 * developers to perform background and low priority work on the main event loop, without impacting
 * latency-critical events such as animation and input response. Functions are generally called in
 * first-in-first-out order; however, callbacks which have a `timeout` specified may be called
 * out-of-order if necessary in order to run them before the timeout elapses.
 *
 * - If `requestIdleCallback` is not available, this function will wait for a new animation frame.
 * - This is safe to call server-side, the given `callback` won't be invoked.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback}
 */
function waitIdlePeriod(
  callback,
  options,
) {
  if (IS_SERVER) return Promise.resolve();
  return new Promise((resolve) => {
    requestIdleCallback((deadline) => {
      callback?.(deadline);
      resolve();
    }, options);
  });
}

function useSignalRecord($state) {
  const [, scheduleReactUpdate] = React.useState(),
    tracking = React.useRef(null) 



;

  if (tracking.current == null) {
    tracking.current = {
      state: {},
      $update: signal({}),
      props: new Set(),
    };
  }

  React.useEffect(() => {
    let { state, $update, props } = tracking.current;
    return effect(() => {
      for (const prop of props) {
        const value = $state[prop ]();
        state[prop] = isArray(value) ? [...value] : value;
      }

      $update();
      scheduleReactUpdate({});
    });
  }, [$state]);

  return React.useMemo(() => {
    let { state, $update, props } = tracking.current,
      scheduledUpdate = false;

    props.clear();

    return new Proxy(state, {
      get(_, prop) {
        if (!props.has(prop) && prop in $state) {
          props.add(prop);

          const value = $state[prop ]();
          state[prop] = isArray(value) ? [...value] : value;

          if (!scheduledUpdate) {
            $update.set({});
            scheduledUpdate = true;
            queueMicrotask(() => (scheduledUpdate = false));
          }
        }

        return state[prop];
      },
      set(_, prop, newValue) {
        if (!(prop in $state)) state[prop] = newValue;
        return true;
      },
    }) ;
  }, [$state]);
}

function createReactComponent(
  Component,
  options,
) {
  if (IS_SERVER) {
    return createServerComponent(Component, {
      props: new Set(Object.keys(Component.props || {})),
    });
  } else {
    return createClientComponent(Component, {
      props: new Set(Object.keys(Component.props || {})),
      events: new Set(options?.events ),
      eventsRE: options?.eventsRegex,
      domEvents: options?.domEvents,
      domEventsRE: options?.domEventsRegex,
    }) ;
  }
}

export { Component, DOMEvent, EventTriggers, EventsController, EventsTarget, Instance, ReactScopeContext, State, ViewController, WithScope, animationFrameThrottle, anySignal, appendTriggerEvent, ariaBool, attachDeclarativeShadowDOM, camelToKebabCase, camelToTitleCase, composeRefs, computed, createComment, createComponent, createContext, createDisposalBin, createFragment, createReactComponent, createReactContextProvider, createReactScopeProvider, createRegex, createScope, deferredPromise, effect, findTriggerEvent, flattenArray, getOriginEvent, getScope, getSlottedChildren, hasProvidedContext, hasTriggerEvent, isArray, isBoolean, isDOMElement, isDOMEvent, isDOMFragment, isDOMNode, isFunction, isKeyboardClick, isKeyboardEvent, isMouseEvent, isNil, isNull, isNumber, isObject, isPointerEvent, isReadSignal, isString, isTouchEvent, isUndefined, isWindow, isWriteSignal, kebabToCamelCase, kebabToPascalCase, kebabToTitleCase, keysOf, listenEvent, lowercaseFirstLetter, mergeProperties, method, noop, omit, onDispose, onError, peek, pick, prop, provideContext, readonly, root, run, runAll, scoped, setAttribute, setRef, setStyle, signal, tick, timedPromise, toggleClass, trimTrailingSemicolon, untrack, unwrap, unwrapDeep, uppercaseFirstChar, useContext, useDisposalBin, useReactContext, useReactScope, useSignal, useSignalRecord, useState, useStateContext, waitAnimationFrame, waitIdlePeriod, waitTimeout, walkTriggerEventChain, wasEnterKeyPressed, wasEscapeKeyPressed };
