import { d as dirname, r as resolveConfigPaths, T as TS_NODE, i as isUndefined, c as camelToKebabCase, e as escapeQuotes, u as uniqueOnly, k as kebabToPascalCase } from './array.js';
import { writeFileSync } from 'node:fs';

const DEFAULT_CONFIG$1 = {
  cwd: process.cwd(),
  outFile: "./analyze.json"
};
const replacer = (key, value) => {
  return key !== TS_NODE ? value : void 0;
};
const createJSONPlugin = (config = {}) => ({
  name: "maverick/json",
  async transform({ components, customElements, reactComponents }) {
    const normalizedConfig = await normalizeJSONPluginConfig(config);
    const output = {
      components,
      elements: customElements,
      react: reactComponents
    };
    const stringify = config.stringifyJson ?? JSON.stringify;
    const finalOutput = normalizedConfig.transformJson?.(output) ?? output;
    const dir = dirname(normalizedConfig.outFile);
    const { existsSync, mkdirSync, writeFileSync } = await import('node:fs');
    if (!existsSync(dir))
      mkdirSync(dir, { recursive: true });
    writeFileSync(
      normalizedConfig.outFile,
      stringify(finalOutput, replacer, 2)
    );
  }
});
async function normalizeJSONPluginConfig(config) {
  return resolveConfigPaths(config.cwd ?? DEFAULT_CONFIG$1.cwd, {
    ...DEFAULT_CONFIG$1,
    ...config
  });
}

const DEFAULT_CONFIG = {
  cwd: process.cwd(),
  outFile: "./vscode.html-data.json"
};
const primitiveTypeRE = /undefined|null|string|boolean|number|any|unknown|never/;
const createVSCodePlugin = (config = {}) => ({
  name: "maverick/vscode-html-data",
  async transform({ components, customElements }) {
    const normalizedConfig = await normalizeVSCodePluginConfig(config);
    const output = {
      version: 1.1,
      tags: []
    };
    const map = /* @__PURE__ */ new Map();
    for (const el of customElements) {
      if (!el.component)
        continue;
      const component = components.find((c) => c.name === el.component.name);
      map.set(el, component);
    }
    customElements.filter((el) => !isUndefined(el.tag) && map.has(el)).forEach((element) => {
      const component = map.get(element);
      const tagData = {
        name: element.tag.name,
        description: element.docs || component?.docs,
        attributes: (component?.props ?? []).filter((prop) => {
          const attr = element.attrs?.[prop.name]?.attr;
          return attr !== false && !prop.readonly && !prop.internal;
        }).map((prop) => {
          const attr = element.attrs?.[prop.name]?.attr;
          const data = {
            name: attr || camelToKebabCase(prop.name),
            description: prop.docs,
            values: prop.type.full.includes("|") ? prop.type.full.split(/\s+\|\s+/)?.filter((value) => !primitiveTypeRE.test(value)).map((type) => ({ name: escapeQuotes(type) })) : void 0
          };
          return config.transformAttributeData?.(prop, data) ?? data;
        })
      };
      output.tags?.push(config.transformTagData?.({ element, component }, tagData) ?? tagData);
    });
    const dir = dirname(normalizedConfig.outFile);
    const { existsSync, mkdirSync, writeFileSync } = await import('node:fs');
    if (!existsSync(dir))
      mkdirSync(dir, { recursive: true });
    writeFileSync(
      normalizedConfig.outFile,
      JSON.stringify(config.transformOutput?.(output) ?? output, void 0, 2)
    );
  }
});
async function normalizeVSCodePluginConfig(config) {
  return resolveConfigPaths(config.cwd ?? DEFAULT_CONFIG.cwd, {
    ...DEFAULT_CONFIG,
    ...config
  });
}

function vueJSXTypesPlugin({
  file = "vue.d.ts",
  imports = [],
  components: userComponents = []
} = {}) {
  return {
    name: "maverick/vue-jsx-types",
    async transform({ components, customElements }) {
      const elementImports = customElements.map((el) => el.name), typeImports = customElements.map((el) => el.component?.name && components.find((c) => c.name === el.component.name)).flatMap((c) => c ? [c.generics?.props, c.generics?.events].filter(Boolean) : []), globalComponents = customElements.map(
        (el) => `"${el.tag.name}": ${el.name.replace("Element", "") + "Component"}`
      );
      const dts = [
        "import type { HTMLAttributes, Ref, ReservedProps } from 'vue';",
        `import type { ${elementImports.join(", ")} } from './elements';`,
        `import type { ${uniqueOnly(typeImports).join(", ")} } from './index';`,
        ...imports,
        "",
        "declare module 'vue' {",
        "  export interface GlobalComponents {",
        `    ${[...globalComponents, ...userComponents].join(";\n    ")}`,
        "  }",
        "}",
        "",
        "export type ElementRef<T> = string | Ref<T> | ((el: T | null) => void);",
        "",
        "export interface EventHandler<T> {",
        "  (event: T): void;",
        "}",
        ...customElements.map((el) => {
          const name = el.name.replace("Element", ""), component = components.find((c) => c.name === el.component?.name), propsType = component?.generics?.props, eventsType = component?.generics?.events, hasEvents = eventsType && component?.events?.length, attrsName = `${name}Attributes`, eventsAttrsName = `${name}EventAttributes`, omitHTMLAttrs = [
            propsType && `keyof ${propsType}`,
            hasEvents && `keyof ${eventsAttrsName}`,
            '"is"'
          ].filter(Boolean).join(" | "), _extends = [
            propsType && `Partial<${propsType}>`,
            hasEvents && eventsAttrsName,
            `Omit<HTMLAttributes, ${omitHTMLAttrs}>`,
            "Omit<ReservedProps, 'ref'>"
          ].filter(Boolean);
          return [
            "/**********************************************************************************************",
            `* ${name}`,
            "/**********************************************************************************************/",
            "",
            `export interface ${name}Component {`,
            `  (props: ${attrsName}): ${el.name};`,
            "}",
            "",
            `export interface ${attrsName} extends ${_extends.join(", ")} {`,
            "  'keep-alive'?: boolean;",
            `  ref?: ElementRef<${el.name}>;`,
            "}",
            "",
            ...hasEvents ? [
              `export interface ${eventsAttrsName} {`,
              component.events.map(
                (event) => `  on${kebabToPascalCase(event.name)}?: EventHandler<${eventsType}['${event.name}']>;`
              ).join("\n"),
              "}"
            ] : [],
            ""
          ].join("\n");
        })
      ];
      writeFileSync(file, dts.join("\n"));
    }
  };
}

function solidJSXTypesPlugin({
  file = "solid.d.ts",
  imports = [],
  components: userComponents = []
} = {}) {
  return {
    name: "maverick/solid-jsx-types",
    async transform({ components, customElements }) {
      const elementImports = customElements.map((el) => el.name), typeImports = customElements.map((el) => el.component?.name && components.find((c) => c.name === el.component.name)).flatMap((c) => c ? [c.generics?.props, c.generics?.events].filter(Boolean) : []), solidElements = customElements.map(
        (el) => `"${el.tag.name}": ${el.name.replace("Element", "") + "Attributes"}`
      );
      const dts = [
        "import type { JSX } from 'solid-js';",
        `import type { ${elementImports.join(", ")} } from './elements';`,
        `import type { ${uniqueOnly(typeImports).join(", ")} } from './index';`,
        ...imports,
        "",
        'declare module "solid-js"{',
        "  namespace JSX {",
        "    interface IntrinsicElements {",
        `      ${[...solidElements, ...userComponents].join(";\n    ")}`,
        "    }",
        "  }",
        "}",
        "",
        "export interface EventHandler<T> {",
        "  (event: T): void;",
        "}",
        ...customElements.map((el) => {
          const name = el.name.replace("Element", ""), component = components.find((c) => c.name === el.component?.name), propsType = component?.generics?.props, eventsType = component?.generics?.events, hasEvents = eventsType && component?.events?.length, attrsName = `${name}Attributes`, eventsAttrsName = `${name}EventAttributes`, omitHTMLAttrs = [
            propsType && `keyof ${propsType}`,
            hasEvents && `keyof ${eventsAttrsName}`,
            '"is"'
          ].filter(Boolean).join(" | "), _extends = [
            propsType && `Partial<${propsType}>`,
            hasEvents && eventsAttrsName,
            `Omit<JSX.HTMLAttributes<${el.name}>, ${omitHTMLAttrs}>`
          ].filter(Boolean);
          return [
            "/**********************************************************************************************",
            `* ${name}`,
            "/**********************************************************************************************/",
            "",
            "",
            `export interface ${attrsName} extends ${_extends.join(", ")} {`,
            "  'keep-alive'?: boolean;",
            "}",
            "",
            ...hasEvents ? [
              `export interface ${eventsAttrsName} {`,
              component.events.map((event) => {
                const docs = event.docs ? `/**
${event.docs}
${event.doctags?.map((tag) => `@${tag.name} ${tag.text}`).join("\n")}
*/
  ` : "";
                return `  ${docs}"on:${event.name}"?: EventHandler<${eventsType}['${event.name}']>;`;
              }).join("\n"),
              "}"
            ] : [],
            ""
          ].join("\n");
        })
      ];
      writeFileSync(file, dts.join("\n"));
    }
  };
}

function svelteJSXTypesPlugin({
  file = "svelte.d.ts",
  imports = [],
  components: userComponents = []
} = {}) {
  return {
    name: "maverick/svelte-jsx-types",
    async transform({ components, customElements }) {
      const elementImports = customElements.map((el) => el.name), typeImports = customElements.map((el) => el.component?.name && components.find((c) => c.name === el.component.name)).flatMap((c) => c ? [c.generics?.props, c.generics?.events].filter(Boolean) : []), svelteElements = customElements.map(
        (el) => `"${el.tag.name}": ${el.name.replace("Element", "") + "Attributes"}`
      );
      const dts = [
        `import type { ${elementImports.join(", ")} } from './elements';`,
        `import type { ${uniqueOnly(typeImports).join(", ")} } from './index';`,
        ...imports,
        "",
        "declare global {",
        "  namespace svelteHTML {",
        "    interface IntrinsicElements {",
        `      ${[...svelteElements, ...userComponents].join(";\n    ")}`,
        "    }",
        "  }",
        "}",
        "",
        "export interface EventHandler<T> {",
        "  (event: T): void;",
        "}",
        ...customElements.map((el) => {
          const name = el.name.replace("Element", ""), component = components.find((c) => c.name === el.component?.name), propsType = component?.generics?.props, eventsType = component?.generics?.events, hasEvents = eventsType && component?.events?.length, attrsName = `${name}Attributes`, eventsAttrsName = `${name}EventAttributes`, omitHTMLAttrs = [
            propsType && `keyof ${propsType}`,
            hasEvents && `keyof ${eventsAttrsName}`,
            '"is"'
          ].filter(Boolean).join(" | "), _extends = [
            propsType && `Partial<${propsType}>`,
            hasEvents && eventsAttrsName,
            `Omit<import('svelte/elements').HTMLAttributes<${el.name}>, ${omitHTMLAttrs}>`
          ].filter(Boolean);
          return [
            "/**********************************************************************************************",
            `* ${name}`,
            "/**********************************************************************************************/",
            "",
            "",
            `export interface ${attrsName} extends ${_extends.join(", ")} {`,
            "  'keep-alive'?: boolean;",
            "}",
            "",
            ...hasEvents ? [
              `export interface ${eventsAttrsName} {`,
              component.events.map((event) => {
                const docs = event.docs ? `/**
${event.docs}
${event.doctags?.map((tag) => `@${tag.name} ${tag.text}`).join("\n")}
*/
  ` : "";
                return `  ${docs}"on:${event.name}"?: EventHandler<${eventsType}['${event.name}']>;`;
              }).join("\n"),
              "}"
            ] : [],
            ""
          ].join("\n");
        })
      ];
      writeFileSync(file, dts.join("\n"));
    }
  };
}

const propKeys = /* @__PURE__ */ new Set(["props", "callbacks", "state", "events", "cssvars", "cssparts", "slots"]);
function walkComponentDocs(component, callback) {
  if (component.docs) {
    const newDocs = callback(component.docs);
    if (newDocs)
      component.docs = newDocs;
  }
  const keys = Object.keys(component);
  for (const key of keys) {
    if (key === "members" && component.type === "component") {
      if (component.members?.props) {
        for (const prop of component.members.props) {
          if (prop.docs) {
            const newDocs = callback(prop.docs);
            if (newDocs)
              prop.docs = newDocs;
          }
        }
        if (component.members?.methods) {
          for (const method of component.members.methods) {
            if (method.docs) {
              const newDocs = callback(method.docs);
              if (newDocs)
                method.docs = newDocs;
            }
          }
        }
      }
    } else if (propKeys.has(key)) {
      for (const prop of component[key]) {
        if (typeof prop.docs === "string") {
          const newDocs = callback(prop.docs);
          if (newDocs)
            prop.docs = newDocs;
        }
      }
    }
  }
}

export { createJSONPlugin, createVSCodePlugin, solidJSXTypesPlugin, svelteJSXTypesPlugin, vueJSXTypesPlugin, walkComponentDocs };
