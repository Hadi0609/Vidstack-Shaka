import * as React from 'react';
import { provideContext, ON_DISPATCH, createComponent, effect$1 as effect, signal, effect as effect$1 } from './chunks/maverick-m_RKaoRG.js';
import { camelToKebabCase, kebabToPascalCase } from './chunks/maverick-jhjCtVsR.js';
import { getContext, createScope, isFunction, tick, isUndefined, isArray } from './chunks/maverick-3G6tTwt0.js';

const ReactScopeContext = React.createContext({ current: null });
ReactScopeContext.displayName = 'Scope';

function WithScope(scope, ...children) {
  return React.createElement(ReactScopeContext.Provider, { value: scope }, ...children);
}

function useReactScope() {
  return React.useContext(ReactScopeContext).current;
}

function useReactContext(context) {
  const scope = useReactScope();
  return React.useMemo(() => getContext(context.id, scope), [scope]);
}

function createReactScopeProvider() {
  return ScopeProvider;
}

function createReactContextProvider(
  context,
  provide,
) {
  return class ContextProvider extends ScopeProvider {
    static  #context = context;
    static  #provide = provide;
  };
}

class ScopeProvider extends React.Component {
  static  contextType = ReactScopeContext;
  ;

  static #context;
  static #provide;

  #scope;

  constructor(props, context) {
    super(props);

    this.#scope = {
      current: createScope(),
    };

    if (context) context.append(this.#scope.current);

    const Ctor = this.constructor ;
    if (Ctor.#context) provideContext(Ctor.#context, Ctor.#provide?.(), this.#scope.current);
  }

   render() {
    return WithScope(this.#scope, this.props?.children);
  }
}

function setRef(ref, value) {
  if (typeof ref === 'function') {
    (ref )(value);
  } else if (ref) {
    (ref ).current = value;
  }
}



function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}

function createClientComponent(
  Component,
  options,
) {
  const forwardComponent = React.forwardRef((props, forwardRef) => {
    let parentScopeRef = React.useContext(ReactScopeContext),
      scopeRef = React.useRef(null),
      stateRef = React.useRef();

    if (!stateRef.current) {
      const state = createInternalState(),
        component = initComponent(Component, state, props, parentScopeRef.current);

      state.component = component;

      stateRef.current = state;
      scopeRef.current = component.scope;
    }

    function onAttach() {
      let state = stateRef.current,
        scope = parentScopeRef.current;

      window.cancelAnimationFrame(state.destroyId);
      state.destroyId = -1;

      if (state.component.$$.destroyed) {
        const component = initComponent(Component, state, props, scope);
        state.component = component;
        state.attached = false;
        state.forwardRef = false;
        scopeRef.current = component.scope;
      }

      if (state.el) {
        attachToHost(state, state.el);
      }

      if (!state.forwardRef) {
        setRef(forwardRef, state.component);
        state.forwardRef = true;
      }

      return () => detachFromHost(state);
    }

    function onRefChange(el) {
      const state = stateRef.current;

      if (!state.forwardRef) {
        state.el = el;
        return;
      }

      window.cancelAnimationFrame(state.refChangeId);
      state.refChangeId = window.requestAnimationFrame(() => {
        const state = stateRef.current;
        state.refChangeId = -1;

        if (state.el === el) return;

        detachFromHost(state);
        if (el) attachToHost(state, el);

        state.el = el;
      });
    }

    React.useEffect(() => {
      const state = stateRef.current;

      window.cancelAnimationFrame(state.destroyId);
      state.destroyId = -1;

      return function onDestroy() {
        // Headless components will be destroyed by parent scope.
        if (!isFunction(props.children)) return;

        window.cancelAnimationFrame(state.refChangeId);
        state.refChangeId = -1;

        window.cancelAnimationFrame(state.connectId);
        state.connectId = -1;

        window.cancelAnimationFrame(state.destroyId);
        state.destroyId = window.requestAnimationFrame(() => {
          state.destroyId = -1;

          detachFromHost(state);

          state.component.$$.destroy();
          state.component.$$[ON_DISPATCH] = null;

          state.callbacks = {};
          state.domCallbacks = {};

          scopeRef.current = null;
        });
      };
    }, []);

    React.useEffect(tick);

    let state = stateRef.current,
      { children, ...renderProps } = props,
      attrs = {},
      prevPropNames = state.prevProps,
      newPropNames = Object.keys(renderProps);

    state.callbacks = {};

    for (const name of [...prevPropNames, ...newPropNames]) {
      if (options.props.has(name)) {
        state.component.$props[name].set(
          // If the prop was removed we'll use the default value provided on Component creation.
          isUndefined(renderProps[name]) ? Component.props?.[name] : renderProps[name],
        );
      } else if (options.events?.has(name) || options.eventsRE?.test(name)) {
        state.callbacks[name] = renderProps[name];
      } else if (options.domEvents?.has(name) || options.domEventsRE?.test(name)) {
        let type = camelToKebabCase(name.slice(2));
        state.domCallbacks[type] = renderProps[name];
        if (!newPropNames.includes(name)) {
          state.el?.removeEventListener(type, state.onDOMEvent);
          state.listening?.delete(type);
        } else if (state.el && !state.listening?.has(type)) {
          if (!state.listening) state.listening = new Set();
          state.listening.add(type);
          state.el.addEventListener(type, state.onDOMEvent);
        }
      } else {
        attrs[name] = renderProps[name];
      }
    }

    state.prevProps = newPropNames;

    return WithScope(
      scopeRef,
      React.createElement(AttachEffect, {
        effect: onAttach,
      }),
      isFunction(children)
        ? children?.(
            {
              ...attrs,
              suppressHydrationWarning: true,
              ref: onRefChange,
            },
            state.component,
          )
        : children,
    );
  });

  forwardComponent.displayName = Component.name + 'Bridge';
  return forwardComponent;
}

// Run effects in top-down order.
function AttachEffect({ effect }) {
  React.useEffect(effect, []);
  return null;
}
















const eventTypeToCallbackName = new Map();

function createInternalState() {
  const state = {
    el: null,
    prevProps: [],
    callbacks: {},
    domCallbacks: {},
    refChangeId: -1,
    connectId: -1,
    destroyId: -1,
    attached: false,
    forwardRef: false,
    listening: null,
    onDOMEvent(event) {
      const args = !isUndefined((event ).detail)
        ? [(event ).detail, event]
        : [event];

      state.domCallbacks[event.type]?.(...args);
    },
  };

  return state ;
}

function attachToHost(state, el) {
  if (state.el === el && state.attached) return;
  else if (state.attached) detachFromHost(state);

  if (state.domCallbacks) {
    if (!state.listening) state.listening = new Set();
    for (const type of Object.keys(state.domCallbacks)) {
      if (state.listening.has(type)) continue;
      el.addEventListener(type, state.onDOMEvent);
      state.listening.add(type);
    }
  }

  state.component.$$.attach(el);

  state.connectId = window.requestAnimationFrame(() => {
    state.component.$$.connect();
    state.connectId = -1;
  });

  state.attached = true;
}

function detachFromHost(state) {
  if (!state.attached) return;

  window.cancelAnimationFrame(state.connectId);

  state.connectId = -1;
  state.component.$$.detach();
  state.attached = false;

  if (state.el && state.listening) {
    for (const type of state.listening) {
      state.el.removeEventListener(type, state.onDOMEvent);
    }

    state.listening.clear();
  }
}

function onDispatch( event) {
  let callbackProp = eventTypeToCallbackName.get(event.type),
    args = !isUndefined((event ).detail)
      ? [(event ).detail, event]
      : [event];

  if (!callbackProp) {
    eventTypeToCallbackName.set(event.type, (callbackProp = `on${kebabToPascalCase(event.type)}`));
  }

  this.callbacks[callbackProp]?.(...args);
}

function initComponent(
  Component,
  state,
  props,
  scope,
) {
  const component = createComponent(Component, { props, scope });
  component.$$[ON_DISPATCH] = onDispatch.bind(state);
  component.$$.setup();
  return component;
}

function useStateContext(
  state,
) {
  return useReactContext(state) ;
}

function useSignal(signal, key) {
  const [, scheduleReactUpdate] = React.useState();

  React.useEffect(() => {
    return effect(() => {
      signal();
      scheduleReactUpdate({});
    });
  }, [key ?? signal]);

  return signal();
}

function useSignalRecord($state) {
  const [, scheduleReactUpdate] = React.useState(),
    tracking = React.useRef(null) 



;

  if (tracking.current == null) {
    tracking.current = {
      state: {},
      $update: signal({}),
      props: new Set(),
    };
  }

  React.useEffect(() => {
    let { state, $update, props } = tracking.current;
    return effect$1(() => {
      for (const prop of props) {
        const value = $state[prop ]();
        state[prop] = isArray(value) ? [...value] : value;
      }

      $update();
      scheduleReactUpdate({});
    });
  }, [$state]);

  return React.useMemo(() => {
    let { state, $update, props } = tracking.current,
      scheduledUpdate = false;

    props.clear();

    return new Proxy(state, {
      get(_, prop) {
        if (!props.has(prop) && prop in $state) {
          props.add(prop);

          const value = $state[prop ]();
          state[prop] = isArray(value) ? [...value] : value;

          if (!scheduledUpdate) {
            $update.set({});
            scheduledUpdate = true;
            queueMicrotask(() => (scheduledUpdate = false));
          }
        }

        return state[prop];
      },
      set(_, prop, newValue) {
        if (!(prop in $state)) state[prop] = newValue;
        return true;
      },
    }) ;
  }, [$state]);
}

function createReactComponent(
  Component,
  options,
) {
  {
    return createClientComponent(Component, {
      props: new Set(Object.keys(Component.props || {})),
      events: new Set(options?.events ),
      eventsRE: options?.eventsRegex,
      domEvents: options?.domEvents,
      domEventsRE: options?.domEventsRegex,
    }) ;
  }
}

export { ReactScopeContext, WithScope, composeRefs, createReactComponent, createReactContextProvider, createReactScopeProvider, setRef, useReactContext, useReactScope, useSignal, useSignalRecord, useStateContext };
