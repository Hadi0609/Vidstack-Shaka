import { ViewController, effect, PROPS, METHODS, computed, signal, useContext } from './chunks/maverick-m_RKaoRG.js';
export { Instance, createComponent, createContext, hasProvidedContext, isReadSignal, isWriteSignal, provideContext, readonly } from './chunks/maverick-m_RKaoRG.js';
import { scoped } from './chunks/maverick-3G6tTwt0.js';
export { createScope, getScope, onDispose, onError, peek, root, tick, untrack } from './chunks/maverick-3G6tTwt0.js';

class Component extends ViewController




 {
  subscribe(callback) {
    if (!this.state) {
      const name = this.constructor.name;
      throw Error(
        `[maverick] component \`${name}\` can not be subscribed to because it has no internal state`,
      );
    }

    return scoped(() => effect(() => callback(this.state)), this.$$.scope);
  }

  destroy() {
    this.$$.destroy();
  }
}

function prop(target, propertyKey, descriptor) {
  if (!target[PROPS]) target[PROPS] = new Set();
  target[PROPS].add(propertyKey);
}

function method(
  target,
  propertyKey,
  descriptor,
) {
  if (!target[METHODS]) target[METHODS] = new Set();
  target[METHODS].add(propertyKey);
}

/**
 * Converts objects into signals. The factory stores the initial object and enables producing new
 * objects where each value in the provided object becomes a signal.
 *
 * @example
 * ```ts
 * const factory = new State({
 *   foo: 0,
 *   bar: '...',
 *   get baz() {
 *     return this.foo + 1;
 *   }
 * });
 *
 * console.log(factory.record); // logs `{ foo: 0, bar: '...' }`
 *
 * const $state = factory.create();
 *
 * effect(() => console.log($state.foo()));
 * // Run effect ^
 * $state.foo.set(1);
 *
 * // Reset all values
 * factory.reset($state);
 * ```
 */
class State {
   id = Symbol('STATE' );
   record;

  #descriptors

;

  constructor(record) {
    this.record = record;
    this.#descriptors = Object.getOwnPropertyDescriptors(record);
  }

  create() {
    const store = {} ,
      state = new Proxy(store, { get: (_, prop) => store[prop]() });

    for (const name of Object.keys(this.record) ) {
      const getter = this.#descriptors[name].get;
      store[name] = getter ? computed(getter.bind(state)) : signal(this.record[name]);
    }

    return store;
  }

  reset(record, filter) {
    for (const name of Object.keys(record) ) {
      if (!this.#descriptors[name].get && (!filter || filter(name))) {
        (record[name] ).set(this.record[name]);
      }
    }
  }
}





















/**
 * Returns the state record context value for the current component tree.
 */
function useState(state) {
  return useContext(state);
}

export { Component, State, ViewController, computed, effect, method, prop, scoped, signal, useContext, useState };
