import yargs from 'yargs';
import { format, inspect } from 'util';
import { normalize, resolve, dirname, basename, extname, relative } from 'path';
import { readFileSync, statSync, readdirSync, writeFile } from 'fs';
import { notStrictEqual, strictEqual } from 'assert';
import { fileURLToPath } from 'url';
import { a as isFunction, b as isObject, n as normalize$1, s as splitLineBreaks, e as escapeQuotes, T as TS_NODE, f as resolve$1, d as dirname$1, g as filterArrayUnique, h as normalizeLineBreaks, i as isUndefined, k as kebabToPascalCase, j as basename$1, l as extname$1, m as resolvePath, o as isArray, r as resolveConfigPaths } from './array.js';
import ts from 'typescript';
import { createHash } from 'node:crypto';
import { globbySync } from 'globby';

class YError extends Error {
    constructor(msg) {
        super(msg || 'yargs error');
        this.name = 'YError';
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, YError);
        }
    }
}

function getProcessArgvBinIndex() {
    if (isBundledElectronApp())
        return 0;
    return 1;
}
function isBundledElectronApp() {
    return isElectronApp() && !process.defaultApp;
}
function isElectronApp() {
    return !!process.versions.electron;
}
function hideBin(argv) {
    return argv.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() {
    return process.argv[getProcessArgvBinIndex()];
}

/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
function camelCase(str) {
    // Handle the case where an argument is provided as camel case, e.g., fooBar.
    // by ensuring that the string isn't already mixed case:
    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
    if (!isCamelCase) {
        str = str.toLowerCase();
    }
    if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {
        return str;
    }
    else {
        let camelcase = '';
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
            let chr = str.charAt(i);
            if (nextChrUpper) {
                nextChrUpper = false;
                chr = chr.toUpperCase();
            }
            if (i !== 0 && (chr === '-' || chr === '_')) {
                nextChrUpper = true;
            }
            else if (chr !== '-' && chr !== '_') {
                camelcase += chr;
            }
        }
        return camelcase;
    }
}
function decamelize(str, joinString) {
    const lowercase = str.toLowerCase();
    joinString = joinString || '-';
    let notCamelcase = '';
    for (let i = 0; i < str.length; i++) {
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
            notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        }
        else {
            notCamelcase += chrString;
        }
    }
    return notCamelcase;
}
function looksLikeNumber(x) {
    if (x === null || x === undefined)
        return false;
    // if loaded from config, may already be a number.
    if (typeof x === 'number')
        return true;
    // hexadecimal.
    if (/^0x[0-9a-f]+$/i.test(x))
        return true;
    // don't treat 0123 as a number; as it drops the leading '0'.
    if (/^0[^.]/.test(x))
        return false;
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
// take an un-split argv string and tokenize it.
function tokenizeArgString(argString) {
    if (Array.isArray(argString)) {
        return argString.map(e => typeof e !== 'string' ? e + '' : e);
    }
    argString = argString.trim();
    let i = 0;
    let prevC = null;
    let c = null;
    let opening = null;
    const args = [];
    for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        // split on spaces unless we're in quotes.
        if (c === ' ' && !opening) {
            if (!(prevC === ' ')) {
                i++;
            }
            continue;
        }
        // don't split the string if we're in matching
        // opening or closing single and double quotes.
        if (c === opening) {
            opening = null;
        }
        else if ((c === "'" || c === '"') && !opening) {
            opening = c;
        }
        if (!args[i])
            args[i] = '';
        args[i] += c;
    }
    return args;
}

/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
var DefaultValuesForTypeKey;
(function (DefaultValuesForTypeKey) {
    DefaultValuesForTypeKey["BOOLEAN"] = "boolean";
    DefaultValuesForTypeKey["STRING"] = "string";
    DefaultValuesForTypeKey["NUMBER"] = "number";
    DefaultValuesForTypeKey["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
let mixin$1;
class YargsParser {
    constructor(_mixin) {
        mixin$1 = _mixin;
    }
    parse(argsInput, options) {
        const opts = Object.assign({
            alias: undefined,
            array: undefined,
            boolean: undefined,
            config: undefined,
            configObjects: undefined,
            configuration: undefined,
            coerce: undefined,
            count: undefined,
            default: undefined,
            envPrefix: undefined,
            narg: undefined,
            normalize: undefined,
            string: undefined,
            number: undefined,
            __: undefined,
            key: undefined
        }, options);
        // allow a string argument to be passed in rather
        // than an argv array.
        const args = tokenizeArgString(argsInput);
        // tokenizeArgString adds extra quotes to args if argsInput is a string
        // only strip those extra quotes in processValue if argsInput is a string
        const inputIsString = typeof argsInput === 'string';
        // aliases might have transitive relationships, normalize this.
        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
        const configuration = Object.assign({
            'boolean-negation': true,
            'camel-case-expansion': true,
            'combine-arrays': false,
            'dot-notation': true,
            'duplicate-arguments-array': true,
            'flatten-duplicate-arrays': true,
            'greedy-arrays': true,
            'halt-at-non-option': false,
            'nargs-eats-options': false,
            'negation-prefix': 'no-',
            'parse-numbers': true,
            'parse-positional-numbers': true,
            'populate--': false,
            'set-placeholder-key': false,
            'short-option-groups': true,
            'strip-aliased': false,
            'strip-dashed': false,
            'unknown-options-as-args': false
        }, opts.configuration);
        const defaults = Object.assign(Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration['populate--'];
        const notFlagsArgv = notFlagsOption ? '--' : '_';
        const newAliases = Object.create(null);
        const defaulted = Object.create(null);
        // allow a i18n handler to be passed in, default to a fake one (util.format).
        const __ = opts.__ || mixin$1.format;
        const flags = {
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {
            const key = typeof opt === 'object' ? opt.key : opt;
            // assign to flags[bools|strings|numbers]
            const assignment = Object.keys(opt).map(function (key) {
                const arrayFlagKeys = {
                    boolean: 'bools',
                    string: 'strings',
                    number: 'numbers'
                };
                return arrayFlagKeys[key];
            }).filter(Boolean).pop();
            // assign key to be coerced
            if (assignment) {
                flags[assignment][key] = true;
            }
            flags.arrays[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {
            flags.bools[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {
            flags.numbers[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {
            flags.counts[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {
            flags.normalize[key] = true;
            flags.keys.push(key);
        });
        if (typeof opts.narg === 'object') {
            Object.entries(opts.narg).forEach(([key, value]) => {
                if (typeof value === 'number') {
                    flags.nargs[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.coerce === 'object') {
            Object.entries(opts.coerce).forEach(([key, value]) => {
                if (typeof value === 'function') {
                    flags.coercions[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.config !== 'undefined') {
            if (Array.isArray(opts.config) || typeof opts.config === 'string') {
                [].concat(opts.config).filter(Boolean).forEach(function (key) {
                    flags.configs[key] = true;
                });
            }
            else if (typeof opts.config === 'object') {
                Object.entries(opts.config).forEach(([key, value]) => {
                    if (typeof value === 'boolean' || typeof value === 'function') {
                        flags.configs[key] = value;
                    }
                });
            }
        }
        // create a lookup table that takes into account all
        // combinations of aliases: {f: ['foo'], foo: ['f']}
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        // apply default values to all aliases.
        Object.keys(defaults).forEach(function (key) {
            (flags.aliases[key] || []).forEach(function (alias) {
                defaults[alias] = defaults[key];
            });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(Object.create(null), { _: [] });
        // TODO(bcoe): for the first pass at removing object prototype  we didn't
        // remove all prototypes from objects returned by this API, we might want
        // to gradually move towards doing so.
        const argvReturn = {};
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            const truncatedArg = arg.replace(/^-{3,}/, '---');
            let broken;
            let key;
            let letters;
            let m;
            let next;
            let value;
            // any unknown option (except for end-of-options, "--")
            if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
                pushPositional(arg);
                // ---, ---=, ----, etc,
            }
            else if (truncatedArg.match(/^---+(=|$)/)) {
                // options without key name are invalid.
                pushPositional(arg);
                continue;
                // -- separated by =
            }
            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
                // arrays format = '--f=a b c'
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    if (checkAllAliases(m[1], flags.arrays)) {
                        i = eatArray(i, m[1], args, m[2]);
                    }
                    else if (checkAllAliases(m[1], flags.nargs) !== false) {
                        // nargs format = '--f=monkey washing cat'
                        i = eatNargs(i, m[1], args, m[2]);
                    }
                    else {
                        setArg(m[1], m[2], true);
                    }
                }
            }
            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
                m = arg.match(negatedBoolean);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
                }
                // -- separated by space.
            }
            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {
                m = arg.match(/^--?(.+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (checkAllAliases(key, flags.arrays)) {
                        // array format = '--foo a b c'
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        // nargs format = '--foo a b c'
                        // should be truthy even if: flags.nargs[key] === 0
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined && (!next.match(/^-/) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
                // dot-notation flag separated by '='.
            }
            else if (arg.match(/^-.\..+=/)) {
                m = arg.match(/^-([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    setArg(m[1], m[2]);
                }
                // dot-notation flag separated by space.
            }
            else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
                next = args[i + 1];
                m = arg.match(/^-(.\..+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (next !== undefined && !next.match(/^-/) &&
                        !checkAllAliases(key, flags.bools) &&
                        !checkAllAliases(key, flags.counts)) {
                        setArg(key, next);
                        i++;
                    }
                    else {
                        setArg(key, defaultValue(key));
                    }
                }
            }
            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
                letters = arg.slice(1, -1).split('');
                broken = false;
                for (let j = 0; j < letters.length; j++) {
                    next = arg.slice(j + 2);
                    if (letters[j + 1] && letters[j + 1] === '=') {
                        value = arg.slice(j + 3);
                        key = letters[j];
                        if (checkAllAliases(key, flags.arrays)) {
                            // array format = '-f=a b c'
                            i = eatArray(i, key, args, value);
                        }
                        else if (checkAllAliases(key, flags.nargs) !== false) {
                            // nargs format = '-f=monkey washing cat'
                            i = eatNargs(i, key, args, value);
                        }
                        else {
                            setArg(key, value);
                        }
                        broken = true;
                        break;
                    }
                    if (next === '-') {
                        setArg(letters[j], next);
                        continue;
                    }
                    // current letter is an alphabetic character and next value is a number
                    if (/[A-Za-z]/.test(letters[j]) &&
                        /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) &&
                        checkAllAliases(next, flags.bools) === false) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], defaultValue(letters[j]));
                    }
                }
                key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (checkAllAliases(key, flags.arrays)) {
                        // array format = '-f a b c'
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        // nargs format = '-f a b c'
                        // should be truthy even if: flags.nargs[key] === 0
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            }
            else if (arg.match(/^-[0-9]$/) &&
                arg.match(negative) &&
                checkAllAliases(arg.slice(1), flags.bools)) {
                // single-digit boolean alias, e.g: xargs -0
                key = arg.slice(1);
                setArg(key, defaultValue(key));
            }
            else if (arg === '--') {
                notFlags = args.slice(i + 1);
                break;
            }
            else if (configuration['halt-at-non-option']) {
                notFlags = args.slice(i);
                break;
            }
            else {
                pushPositional(arg);
            }
        }
        // order of precedence:
        // 1. command line arg
        // 2. value from env var
        // 3. value from config file
        // 4. value from config objects
        // 5. configured default value
        applyEnvVars(argv, true); // special case: check env vars that point to config file
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration['set-placeholder-key'])
            setPlaceholderKeys(argv);
        // for any counts either not in args or without an explicit default, set to 0
        Object.keys(flags.counts).forEach(function (key) {
            if (!hasKey(argv, key.split('.')))
                setArg(key, 0);
        });
        // '--' defaults to undefined.
        if (notFlagsOption && notFlags.length)
            argv[notFlagsArgv] = [];
        notFlags.forEach(function (key) {
            argv[notFlagsArgv].push(key);
        });
        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {
                delete argv[key];
            });
        }
        if (configuration['strip-aliased']) {
            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {
                if (configuration['camel-case-expansion'] && alias.includes('-')) {
                    delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];
                }
                delete argv[alias];
            });
        }
        // Push argument into positional array, applying numeric coercion:
        function pushPositional(arg) {
            const maybeCoercedNumber = maybeCoerceNumber('_', arg);
            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {
                argv._.push(maybeCoercedNumber);
            }
        }
        // how many arguments should we consume, based
        // on the nargs option?
        function eatNargs(i, key, args, argAfterEqualSign) {
            let ii;
            let toEat = checkAllAliases(key, flags.nargs);
            // NaN has a special meaning for the array type, indicating that one or
            // more values are expected.
            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;
            if (toEat === 0) {
                if (!isUndefined(argAfterEqualSign)) {
                    error = Error(__('Argument unexpected for: %s', key));
                }
                setArg(key, defaultValue(key));
                return i;
            }
            let available = isUndefined(argAfterEqualSign) ? 0 : 1;
            if (configuration['nargs-eats-options']) {
                // classic behavior, yargs eats positional and dash arguments.
                if (args.length - (i + 1) + available < toEat) {
                    error = Error(__('Not enough arguments following: %s', key));
                }
                available = toEat;
            }
            else {
                // nargs will not consume flag arguments, e.g., -abc, --foo,
                // and terminates when one is observed.
                for (ii = i + 1; ii < args.length; ii++) {
                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))
                        available++;
                    else
                        break;
                }
                if (available < toEat)
                    error = Error(__('Not enough arguments following: %s', key));
            }
            let consumed = Math.min(available, toEat);
            if (!isUndefined(argAfterEqualSign) && consumed > 0) {
                setArg(key, argAfterEqualSign);
                consumed--;
            }
            for (ii = i + 1; ii < (consumed + i + 1); ii++) {
                setArg(key, args[ii]);
            }
            return (i + consumed);
        }
        // if an option is an array, eat all non-hyphenated arguments
        // following it... YUM!
        // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
        function eatArray(i, key, args, argAfterEqualSign) {
            let argsToSet = [];
            let next = argAfterEqualSign || args[i + 1];
            // If both array and nargs are configured, enforce the nargs count:
            const nargsCount = checkAllAliases(key, flags.nargs);
            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {
                argsToSet.push(true);
            }
            else if (isUndefined(next) ||
                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {
                // for keys without value ==> argsToSet remains an empty []
                // set user default value, if available
                if (defaults[key] !== undefined) {
                    const defVal = defaults[key];
                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];
                }
            }
            else {
                // value in --option=value is eaten as is
                if (!isUndefined(argAfterEqualSign)) {
                    argsToSet.push(processValue(key, argAfterEqualSign, true));
                }
                for (let ii = i + 1; ii < args.length; ii++) {
                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||
                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))
                        break;
                    next = args[ii];
                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                        break;
                    i = ii;
                    argsToSet.push(processValue(key, next, inputIsString));
                }
            }
            // If both array and nargs are configured, create an error if less than
            // nargs positionals were found. NaN has special meaning, indicating
            // that at least one value is required (more are okay).
            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||
                (isNaN(nargsCount) && argsToSet.length === 0))) {
                error = Error(__('Not enough arguments following: %s', key));
            }
            setArg(key, argsToSet);
            return i;
        }
        function setArg(key, val, shouldStripQuotes = inputIsString) {
            if (/-/.test(key) && configuration['camel-case-expansion']) {
                const alias = key.split('.').map(function (prop) {
                    return camelCase(prop);
                }).join('.');
                addNewAlias(key, alias);
            }
            const value = processValue(key, val, shouldStripQuotes);
            const splitKey = key.split('.');
            setKey(argv, splitKey, value);
            // handle populating aliases of the full key
            if (flags.aliases[key]) {
                flags.aliases[key].forEach(function (x) {
                    const keyProperties = x.split('.');
                    setKey(argv, keyProperties, value);
                });
            }
            // handle populating aliases of the first element of the dot-notation key
            if (splitKey.length > 1 && configuration['dot-notation']) {
                (flags.aliases[splitKey[0]] || []).forEach(function (x) {
                    let keyProperties = x.split('.');
                    // expand alias with nested objects in key
                    const a = [].concat(splitKey);
                    a.shift(); // nuke the old key.
                    keyProperties = keyProperties.concat(a);
                    // populate alias only if is not already an alias of the full key
                    // (already populated above)
                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {
                        setKey(argv, keyProperties, value);
                    }
                });
            }
            // Set normalize getter and setter when key is in 'normalize' but isn't an array
            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
                const keys = [key].concat(flags.aliases[key] || []);
                keys.forEach(function (key) {
                    Object.defineProperty(argvReturn, key, {
                        enumerable: true,
                        get() {
                            return val;
                        },
                        set(value) {
                            val = typeof value === 'string' ? mixin$1.normalize(value) : value;
                        }
                    });
                });
            }
        }
        function addNewAlias(key, alias) {
            if (!(flags.aliases[key] && flags.aliases[key].length)) {
                flags.aliases[key] = [alias];
                newAliases[alias] = true;
            }
            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
                addNewAlias(alias, key);
            }
        }
        function processValue(key, val, shouldStripQuotes) {
            // strings may be quoted, clean this up as we assign values.
            if (shouldStripQuotes) {
                val = stripQuotes(val);
            }
            // handle parsing boolean arguments --foo=true --bar false.
            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
                if (typeof val === 'string')
                    val = val === 'true';
            }
            let value = Array.isArray(val)
                ? val.map(function (v) { return maybeCoerceNumber(key, v); })
                : maybeCoerceNumber(key, val);
            // increment a count given as arg (either no value or value parsed as boolean)
            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
                value = increment();
            }
            // Set normalized value when key is in 'normalize' and in 'arrays'
            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
                if (Array.isArray(val))
                    value = val.map((val) => { return mixin$1.normalize(val); });
                else
                    value = mixin$1.normalize(val);
            }
            return value;
        }
        function maybeCoerceNumber(key, value) {
            if (!configuration['parse-positional-numbers'] && key === '_')
                return value;
            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));
                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {
                    value = Number(value);
                }
            }
            return value;
        }
        // set args from config.json file, this should be
        // applied last so that defaults can be applied.
        function setConfig(argv) {
            const configLookup = Object.create(null);
            // expand defaults/aliases, in-case any happen to reference
            // the config.json file.
            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
            Object.keys(flags.configs).forEach(function (configKey) {
                const configPath = argv[configKey] || configLookup[configKey];
                if (configPath) {
                    try {
                        let config = null;
                        const resolvedConfigPath = mixin$1.resolve(mixin$1.cwd(), configPath);
                        const resolveConfig = flags.configs[configKey];
                        if (typeof resolveConfig === 'function') {
                            try {
                                config = resolveConfig(resolvedConfigPath);
                            }
                            catch (e) {
                                config = e;
                            }
                            if (config instanceof Error) {
                                error = config;
                                return;
                            }
                        }
                        else {
                            config = mixin$1.require(resolvedConfigPath);
                        }
                        setConfigObject(config);
                    }
                    catch (ex) {
                        // Deno will receive a PermissionDenied error if an attempt is
                        // made to load config without the --allow-read flag:
                        if (ex.name === 'PermissionDenied')
                            error = ex;
                        else if (argv[configKey])
                            error = Error(__('Invalid JSON config file: %s', configPath));
                    }
                }
            });
        }
        // set args from config object.
        // it recursively checks nested objects.
        function setConfigObject(config, prev) {
            Object.keys(config).forEach(function (key) {
                const value = config[key];
                const fullKey = prev ? prev + '.' + key : key;
                // if the value is an inner object and we have dot-notation
                // enabled, treat inner objects in config the same as
                // heavily nested dot notations (foo.bar.apple).
                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
                    // if the value is an object but not an array, check nested object
                    setConfigObject(value, fullKey);
                }
                else {
                    // setting arguments via CLI takes precedence over
                    // values within the config file.
                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {
                        setArg(fullKey, value);
                    }
                }
            });
        }
        // set all config objects passed in opts
        function setConfigObjects() {
            if (typeof configObjects !== 'undefined') {
                configObjects.forEach(function (configObject) {
                    setConfigObject(configObject);
                });
            }
        }
        function applyEnvVars(argv, configOnly) {
            if (typeof envPrefix === 'undefined')
                return;
            const prefix = typeof envPrefix === 'string' ? envPrefix : '';
            const env = mixin$1.env();
            Object.keys(env).forEach(function (envVar) {
                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
                    // get array of nested keys and convert them to camel case
                    const keys = envVar.split('__').map(function (key, i) {
                        if (i === 0) {
                            key = key.substring(prefix.length);
                        }
                        return camelCase(key);
                    });
                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {
                        setArg(keys.join('.'), env[envVar]);
                    }
                }
            });
        }
        function applyCoercions(argv) {
            let coerce;
            const applied = new Set();
            Object.keys(argv).forEach(function (key) {
                if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases
                    coerce = checkAllAliases(key, flags.coercions);
                    if (typeof coerce === 'function') {
                        try {
                            const value = maybeCoerceNumber(key, coerce(argv[key]));
                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {
                                applied.add(ali);
                                argv[ali] = value;
                            });
                        }
                        catch (err) {
                            error = err;
                        }
                    }
                }
            });
        }
        function setPlaceholderKeys(argv) {
            flags.keys.forEach((key) => {
                // don't set placeholder keys for dot notation options 'foo.bar'.
                if (~key.indexOf('.'))
                    return;
                if (typeof argv[key] === 'undefined')
                    argv[key] = undefined;
            });
            return argv;
        }
        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {
            Object.keys(defaults).forEach(function (key) {
                if (!hasKey(obj, key.split('.'))) {
                    setKey(obj, key.split('.'), defaults[key]);
                    if (canLog)
                        defaulted[key] = true;
                    (aliases[key] || []).forEach(function (x) {
                        if (hasKey(obj, x.split('.')))
                            return;
                        setKey(obj, x.split('.'), defaults[key]);
                    });
                }
            });
        }
        function hasKey(obj, keys) {
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) {
                o = (o[key] || {});
            });
            const key = keys[keys.length - 1];
            if (typeof o !== 'object')
                return false;
            else
                return key in o;
        }
        function setKey(obj, keys, value) {
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) {
                // TODO(bcoe): in the next major version of yargs, switch to
                // Object.create(null) for dot notation:
                key = sanitizeKey(key);
                if (typeof o === 'object' && o[key] === undefined) {
                    o[key] = {};
                }
                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {
                    // ensure that o[key] is an array, and that the last item is an empty object.
                    if (Array.isArray(o[key])) {
                        o[key].push({});
                    }
                    else {
                        o[key] = [o[key], {}];
                    }
                    // we want to update the empty object at the end of the o[key] array, so set o to that object
                    o = o[key][o[key].length - 1];
                }
                else {
                    o = o[key];
                }
            });
            // TODO(bcoe): in the next major version of yargs, switch to
            // Object.create(null) for dot notation:
            const key = sanitizeKey(keys[keys.length - 1]);
            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
            const isValueArray = Array.isArray(value);
            let duplicate = configuration['duplicate-arguments-array'];
            // nargs has higher priority than duplicate
            if (!duplicate && checkAllAliases(key, flags.nargs)) {
                duplicate = true;
                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {
                    o[key] = undefined;
                }
            }
            if (value === increment()) {
                o[key] = increment(o[key]);
            }
            else if (Array.isArray(o[key])) {
                if (duplicate && isTypeArray && isValueArray) {
                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
                }
                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
                    o[key] = value;
                }
                else {
                    o[key] = o[key].concat([value]);
                }
            }
            else if (o[key] === undefined && isTypeArray) {
                o[key] = isValueArray ? value : [value];
            }
            else if (duplicate && !(o[key] === undefined ||
                checkAllAliases(key, flags.counts) ||
                checkAllAliases(key, flags.bools))) {
                o[key] = [o[key], value];
            }
            else {
                o[key] = value;
            }
        }
        // extend the aliases list with inferred aliases.
        function extendAliases(...args) {
            args.forEach(function (obj) {
                Object.keys(obj || {}).forEach(function (key) {
                    // short-circuit if we've already added a key
                    // to the aliases array, for example it might
                    // exist in both 'opts.default' and 'opts.key'.
                    if (flags.aliases[key])
                        return;
                    flags.aliases[key] = [].concat(aliases[key] || []);
                    // For "--option-name", also set argv.optionName
                    flags.aliases[key].concat(key).forEach(function (x) {
                        if (/-/.test(x) && configuration['camel-case-expansion']) {
                            const c = camelCase(x);
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    // For "--optionName", also set argv['option-name']
                    flags.aliases[key].concat(key).forEach(function (x) {
                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
                            const c = decamelize(x, '-');
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].forEach(function (x) {
                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
                            return x !== y;
                        }));
                    });
                });
            });
        }
        function checkAllAliases(key, flag) {
            const toCheck = [].concat(flags.aliases[key] || [], key);
            const keys = Object.keys(flag);
            const setAlias = toCheck.find(key => keys.includes(key));
            return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
            const flagsKeys = Object.keys(flags);
            const toCheck = [].concat(flagsKeys.map(k => flags[k]));
            return toCheck.some(function (flag) {
                return Array.isArray(flag) ? flag.includes(key) : flag[key];
            });
        }
        function hasFlagsMatching(arg, ...patterns) {
            const toCheck = [].concat(...patterns);
            return toCheck.some(function (pattern) {
                const match = arg.match(pattern);
                return match && hasAnyFlag(match[1]);
            });
        }
        // based on a simplified version of the short flag group parsing logic
        function hasAllShortFlags(arg) {
            // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group
            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
                return false;
            }
            let hasAllFlags = true;
            let next;
            const letters = arg.slice(1).split('');
            for (let j = 0; j < letters.length; j++) {
                next = arg.slice(j + 2);
                if (!hasAnyFlag(letters[j])) {
                    hasAllFlags = false;
                    break;
                }
                if ((letters[j + 1] && letters[j + 1] === '=') ||
                    next === '-' ||
                    (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ||
                    (letters[j + 1] && letters[j + 1].match(/\W/))) {
                    break;
                }
            }
            return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
            return configuration['unknown-options-as-args'] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
            arg = arg.replace(/^-{3,}/, '--');
            // ignore negative numbers
            if (arg.match(negative)) {
                return false;
            }
            // if this is a short option group and all of them are configured, it isn't unknown
            if (hasAllShortFlags(arg)) {
                return false;
            }
            // e.g. '--count=2'
            const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
            // e.g. '-a' or '--arg'
            const normalFlag = /^-+([^=]+?)$/;
            // e.g. '-a-'
            const flagEndingInHyphen = /^-+([^=]+?)-$/;
            // e.g. '-abc123'
            const flagEndingInDigits = /^-+([^=]+?\d+)$/;
            // e.g. '-a/usr/local'
            const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
            // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method
            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        // make a best effort to pick a default value
        // for an option based on name and type.
        function defaultValue(key) {
            if (!checkAllAliases(key, flags.bools) &&
                !checkAllAliases(key, flags.counts) &&
                `${key}` in defaults) {
                return defaults[key];
            }
            else {
                return defaultForType(guessType(key));
            }
        }
        // return a default value, given the type of a flag.,
        function defaultForType(type) {
            const def = {
                [DefaultValuesForTypeKey.BOOLEAN]: true,
                [DefaultValuesForTypeKey.STRING]: '',
                [DefaultValuesForTypeKey.NUMBER]: undefined,
                [DefaultValuesForTypeKey.ARRAY]: []
            };
            return def[type];
        }
        // given a flag, enforce a default type.
        function guessType(key) {
            let type = DefaultValuesForTypeKey.BOOLEAN;
            if (checkAllAliases(key, flags.strings))
                type = DefaultValuesForTypeKey.STRING;
            else if (checkAllAliases(key, flags.numbers))
                type = DefaultValuesForTypeKey.NUMBER;
            else if (checkAllAliases(key, flags.bools))
                type = DefaultValuesForTypeKey.BOOLEAN;
            else if (checkAllAliases(key, flags.arrays))
                type = DefaultValuesForTypeKey.ARRAY;
            return type;
        }
        function isUndefined(num) {
            return num === undefined;
        }
        // check user configuration settings for inconsistencies
        function checkConfiguration() {
            // count keys should not be set as array/narg
            Object.keys(flags.counts).find(key => {
                if (checkAllAliases(key, flags.arrays)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
                    return true;
                }
                else if (checkAllAliases(key, flags.nargs)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
                    return true;
                }
                return false;
            });
        }
        return {
            aliases: Object.assign({}, flags.aliases),
            argv: Object.assign(argvReturn, argv),
            configuration: configuration,
            defaulted: Object.assign({}, defaulted),
            error: error,
            newAliases: Object.assign({}, newAliases)
        };
    }
}
// if any aliases reference each other, we should
// merge them together.
function combineAliases(aliases) {
    const aliasArrays = [];
    const combined = Object.create(null);
    let change = true;
    // turn alias lookup hash {key: ['alias1', 'alias2']} into
    // a simple array ['key', 'alias1', 'alias2']
    Object.keys(aliases).forEach(function (key) {
        aliasArrays.push([].concat(aliases[key], key));
    });
    // combine arrays until zero changes are
    // made in an iteration.
    while (change) {
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) {
            for (let ii = i + 1; ii < aliasArrays.length; ii++) {
                const intersect = aliasArrays[i].filter(function (v) {
                    return aliasArrays[ii].indexOf(v) !== -1;
                });
                if (intersect.length) {
                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
                    aliasArrays.splice(ii, 1);
                    change = true;
                    break;
                }
            }
        }
    }
    // map arrays back to the hash-lookup (de-dupe while
    // we're at it).
    aliasArrays.forEach(function (aliasArray) {
        aliasArray = aliasArray.filter(function (v, i, self) {
            return self.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== undefined && typeof lastAlias === 'string') {
            combined[lastAlias] = aliasArray;
        }
    });
    return combined;
}
// this function should only be called when a count is given as an arg
// it is NOT called to set a default value
// thus we can start the count at 1 instead of 0
function increment(orig) {
    return orig !== undefined ? orig + 1 : 1;
}
// TODO(bcoe): in the next major version of yargs, switch to
// Object.create(null) for dot notation:
function sanitizeKey(key) {
    if (key === '__proto__')
        return '___proto___';
    return key;
}
function stripQuotes(val) {
    return (typeof val === 'string' &&
        (val[0] === "'" || val[0] === '"') &&
        val[val.length - 1] === val[0])
        ? val.substring(1, val.length - 1)
        : val;
}

/**
 * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
 * CJS and ESM environments.
 *
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
var _a, _b, _c;
// See https://github.com/yargs/yargs-parser#supported-nodejs-versions for our
// version support policy. The YARGS_MIN_NODE_VERSION is used for testing only.
const minNodeVersion = (process && process.env && process.env.YARGS_MIN_NODE_VERSION)
    ? Number(process.env.YARGS_MIN_NODE_VERSION)
    : 12;
const nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
if (nodeVersion) {
    const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
    if (major < minNodeVersion) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
    }
}
// Creates a yargs-parser instance using Node.js standard libraries:
const env = process ? process.env : {};
const parser = new YargsParser({
    cwd: process.cwd,
    env: () => {
        return env;
    },
    format,
    normalize,
    resolve,
    // TODO: figure  out a  way to combine ESM and CJS coverage, such  that
    // we can exercise all the lines below:
    require: (path) => {
        if (typeof require !== 'undefined') {
            return require(path);
        }
        else if (path.match(/\.json$/)) {
            // Addresses: https://github.com/yargs/yargs/issues/2040
            return JSON.parse(readFileSync(path, 'utf8'));
        }
        else {
            throw Error('only .json config files are supported in ESM');
        }
    }
});
const yargsParser = function Parser(args, opts) {
    const result = parser.parse(args.slice(), opts);
    return result.argv;
};
yargsParser.detailed = function (args, opts) {
    return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;

const align = {
    right: alignRight,
    center: alignCenter
};
const top = 0;
const right = 1;
const bottom = 2;
const left = 3;
class UI {
    constructor(opts) {
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
    }
    span(...args) {
        const cols = this.div(...args);
        cols.span = true;
    }
    resetOutput() {
        this.rows = [];
    }
    div(...args) {
        if (args.length === 0) {
            this.div('');
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
            return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map(arg => {
            if (typeof arg === 'string') {
                return this.colFromString(arg);
            }
            return arg;
        });
        this.rows.push(cols);
        return cols;
    }
    shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === 'string' &&
            /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
        const rows = str.split('\n').map(row => row.split('\t'));
        let leftColumnWidth = 0;
        // simple heuristic for layout, make sure the
        // second column lines up along the left-hand.
        // don't allow the first column to take up more
        // than 50% of the screen.
        rows.forEach(columns => {
            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
            }
        });
        // generate a table:
        //  replacing ' ' with padding calculations.
        //  using the algorithmically generated width.
        rows.forEach(columns => {
            this.div(...columns.map((r, i) => {
                return {
                    text: r.trim(),
                    padding: this.measurePadding(r),
                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
                };
            }));
        });
        return this.rows[this.rows.length - 1];
    }
    colFromString(text) {
        return {
            text,
            padding: this.measurePadding(text)
        };
    }
    measurePadding(str) {
        // measure padding without ansi escape codes
        const noAnsi = mixin.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
    toString() {
        const lines = [];
        this.rows.forEach(row => {
            this.rowToString(row, lines);
        });
        // don't display any lines with the
        // hidden flag set.
        return lines
            .filter(line => !line.hidden)
            .map(line => line.text)
            .join('\n');
    }
    rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
            let str = '';
            rrow.forEach((col, c) => {
                const { width } = row[c]; // the width with padding.
                const wrapWidth = this.negatePadding(row[c]); // the width without padding.
                let ts = col; // temporary string used during alignment/padding.
                if (wrapWidth > mixin.stringWidth(col)) {
                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
                }
                // align the string within its column.
                if (row[c].align && row[c].align !== 'left' && this.wrap) {
                    const fn = align[row[c].align];
                    ts = fn(ts, wrapWidth);
                    if (mixin.stringWidth(ts) < wrapWidth) {
                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);
                    }
                }
                // apply border and padding to string.
                const padding = row[c].padding || [0, 0, 0, 0];
                if (padding[left]) {
                    str += ' '.repeat(padding[left]);
                }
                str += addBorder(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[right]) {
                    str += ' '.repeat(padding[right]);
                }
                // if prior row is span, try to render the
                // current row on the prior line.
                if (r === 0 && lines.length > 0) {
                    str = this.renderInline(str, lines[lines.length - 1]);
                }
            });
            // remove trailing whitespace.
            lines.push({
                text: str.replace(/ +$/, ''),
                span: row.span
            });
        });
        return lines;
    }
    // if the full 'source' can render in
    // the target line, do so.
    renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
            return source;
        }
        // if we're not applying wrapping logic,
        // just always append to the span.
        if (!this.wrap) {
            previousLine.hidden = true;
            return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
            return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
    rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        // word wrap all columns, and create
        // a data-structure that is easy to rasterize.
        row.forEach((col, c) => {
            // leave room for left and right padding.
            col.width = widths[c];
            if (this.wrap) {
                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\n');
            }
            else {
                wrapped = col.text.split('\n');
            }
            if (col.border) {
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
            }
            // add top and bottom padding.
            if (col.padding) {
                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));
                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
            }
            wrapped.forEach((str, r) => {
                if (!rrows[r]) {
                    rrows.push([]);
                }
                const rrow = rrows[r];
                for (let i = 0; i < c; i++) {
                    if (rrow[i] === undefined) {
                        rrow.push('');
                    }
                }
                rrow.push(str);
            });
        });
        return rrows;
    }
    negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
            wrapWidth -= 4;
        }
        return wrapWidth;
    }
    columnWidths(row) {
        if (!this.wrap) {
            return row.map(col => {
                return col.width || mixin.stringWidth(col.text);
            });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        // column widths can be set in config.
        const widths = row.map(col => {
            if (col.width) {
                unset--;
                remainingWidth -= col.width;
                return col.width;
            }
            return undefined;
        });
        // any unset widths should be calculated.
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
            if (w === undefined) {
                return Math.max(unsetWidth, _minWidth(row[i]));
            }
            return w;
        });
    }
}
function addBorder(col, ts, style) {
    if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
            return '';
        }
        if (ts.trim().length !== 0) {
            return style;
        }
        return '  ';
    }
    return '';
}
// calculates the minimum width of
// a column, based on padding preferences.
function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) {
        return minWidth + 4;
    }
    return minWidth;
}
function getWindowWidth() {
    /* istanbul ignore next: depends on terminal */
    if (typeof process === 'object' && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
    }
    return 80;
}
function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) {
        return ' '.repeat(width - strWidth) + str;
    }
    return str;
}
function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    /* istanbul ignore next */
    if (strWidth >= width) {
        return str;
    }
    return ' '.repeat((width - strWidth) >> 1) + str;
}
let mixin;
function cliui(opts, _mixin) {
    mixin = _mixin;
    return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
    });
}

// Minimal replacement for ansi string helpers "wrap-ansi" and "strip-ansi".
// to facilitate ESM and Deno modules.
// TODO: look at porting https://www.npmjs.com/package/wrap-ansi to ESM.
// The npm application
// Copyright (c) npm, Inc. and Contributors
// Licensed on the terms of The Artistic License 2.0
// See: https://github.com/npm/cli/blob/4c65cd952bc8627811735bea76b9b110cc4fc80e/lib/utils/ansi-trim.js
const ansi = new RegExp('\x1b(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|' +
    '\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)', 'g');
function stripAnsi(str) {
    return str.replace(ansi, '');
}
function wrap(str, width) {
    const [start, end] = str.match(ansi) || ['', ''];
    str = stripAnsi(str);
    let wrapped = '';
    for (let i = 0; i < str.length; i++) {
        if (i !== 0 && (i % width) === 0) {
            wrapped += '\n';
        }
        wrapped += str.charAt(i);
    }
    if (start && end) {
        wrapped = `${start}${wrapped}${end}`;
    }
    return wrapped;
}

// Bootstrap cliui with CommonJS dependencies:

function ui (opts) {
  return cliui(opts, {
    stringWidth: (str) => {
      return [...str].length
    },
    stripAnsi,
    wrap
  })
}

function escalade (start, callback) {
	let dir = resolve('.', start);
	let tmp, stats = statSync(dir);

	if (!stats.isDirectory()) {
		dir = dirname(dir);
	}

	while (true) {
		tmp = callback(dir, readdirSync(dir));
		if (tmp) return resolve(dir, tmp);
		dir = dirname(tmp = dir);
		if (tmp === dir) break;
	}
}

var shim$1 = {
    fs: {
        readFileSync,
        writeFile
    },
    format,
    resolve,
    exists: (file) => {
        try {
            return statSync(file).isFile();
        }
        catch (err) {
            return false;
        }
    }
};

let shim;
class Y18N {
    constructor(opts) {
        // configurable options.
        opts = opts || {};
        this.directory = opts.directory || './locales';
        this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;
        this.locale = opts.locale || 'en';
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true;
        // internal stuff.
        this.cache = Object.create(null);
        this.writeQueue = [];
    }
    __(...args) {
        if (typeof arguments[0] !== 'string') {
            return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str = args.shift();
        let cb = function () { }; // start with noop.
        if (typeof args[args.length - 1] === 'function')
            cb = args.pop();
        cb = cb || function () { }; // noop.
        if (!this.cache[this.locale])
            this._readLocaleFile();
        // we've observed a new string, update the language file.
        if (!this.cache[this.locale][str] && this.updateFiles) {
            this.cache[this.locale][str] = str;
            // include the current directory and locale,
            // since these values could change before the
            // write is performed.
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        }
        else {
            cb();
        }
        return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
    }
    __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function () { }; // start with noop.
        if (typeof args[args.length - 1] === 'function')
            cb = args.pop();
        if (!this.cache[this.locale])
            this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
            const entry = this.cache[this.locale][singular];
            str = entry[quantity === 1 ? 'one' : 'other'];
        }
        // we've observed a new string, update the language file.
        if (!this.cache[this.locale][singular] && this.updateFiles) {
            this.cache[this.locale][singular] = {
                one: singular,
                other: plural
            };
            // include the current directory and locale,
            // since these values could change before the
            // write is performed.
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        }
        else {
            cb();
        }
        // if a %d placeholder is provided, add quantity
        // to the arguments expanded by util.format.
        const values = [str];
        if (~str.indexOf('%d'))
            values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
    }
    setLocale(locale) {
        this.locale = locale;
    }
    getLocale() {
        return this.locale;
    }
    updateLocale(obj) {
        if (!this.cache[this.locale])
            this._readLocaleFile();
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                this.cache[this.locale][key] = obj[key];
            }
        }
    }
    _taggedLiteral(parts, ...args) {
        let str = '';
        parts.forEach(function (part, i) {
            const arg = args[i + 1];
            str += part;
            if (typeof arg !== 'undefined') {
                str += '%s';
            }
        });
        return this.__.apply(this, [str].concat([].slice.call(args, 1)));
    }
    _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1)
            this._processWriteQueue();
    }
    _processWriteQueue() {
        const _this = this;
        const work = this.writeQueue[0];
        // destructure the enqueued work.
        const directory = work.directory;
        const locale = work.locale;
        const cb = work.cb;
        const languageFile = this._resolveLocaleFile(directory, locale);
        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
            _this.writeQueue.shift();
            if (_this.writeQueue.length > 0)
                _this._processWriteQueue();
            cb(err);
        });
    }
    _readLocaleFile() {
        let localeLookup = {};
        const languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
            // When using a bundler such as webpack, readFileSync may not be defined:
            if (shim.fs.readFileSync) {
                localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));
            }
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                err.message = 'syntax error in ' + languageFile;
            }
            if (err.code === 'ENOENT')
                localeLookup = {};
            else
                throw err;
        }
        this.cache[this.locale] = localeLookup;
    }
    _resolveLocaleFile(directory, locale) {
        let file = shim.resolve(directory, './', locale + '.json');
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
            // attempt fallback to language only
            const languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');
            if (this._fileExistsSync(languageFile))
                file = languageFile;
        }
        return file;
    }
    _fileExistsSync(file) {
        return shim.exists(file);
    }
}
function y18n$1(opts, _shim) {
    shim = _shim;
    const y18n = new Y18N(opts);
    return {
        __: y18n.__.bind(y18n),
        __n: y18n.__n.bind(y18n),
        setLocale: y18n.setLocale.bind(y18n),
        getLocale: y18n.getLocale.bind(y18n),
        updateLocale: y18n.updateLocale.bind(y18n),
        locale: y18n.locale
    };
}

const y18n = (opts) => {
  return y18n$1(opts, shim$1)
};

const REQUIRE_ERROR = 'require is not supported by ESM';
const REQUIRE_DIRECTORY_ERROR = 'loading a directory of commands is not supported yet for ESM';

let __dirname;
try {
  __dirname = fileURLToPath(import.meta.url);
} catch (e) {
  __dirname = process.cwd();
}
const mainFilename = __dirname.substring(0, __dirname.lastIndexOf('node_modules'));

({
  assert: {
    notStrictEqual,
    strictEqual
  },
  cliui: ui,
  findUp: escalade,
  getEnv: (key) => {
    return process.env[key]
  },
  inspect,
  getCallerFile: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR)
  },
  getProcessArgvBin,
  mainFilename: mainFilename || process.cwd(),
  Parser: yargsParser,
  path: {
    basename,
    dirname,
    extname,
    relative,
    resolve
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (warning, type) => process.emitWarning(warning, type),
    execPath: () => process.execPath,
    exit: process.exit,
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null
  },
  readFileSync,
  require: () => {
    throw new YError(REQUIRE_ERROR)
  },
  requireDirectory: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR)
  },
  stringWidth: (str) => {
    return [...str].length
  },
  y18n: y18n({
    directory: resolve(__dirname, '../../../locales'),
    updateFiles: false
  })
});

let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;
if (typeof process !== 'undefined') {
	({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
	isTTY = process.stdout && process.stdout.isTTY;
}

const $ = {
	enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (
		FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY
	),

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run$1(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (!!~str.indexOf(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);
	ctx.grey = $.grey.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $.enabled ? run$1(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $.enabled ? run$1([blk], txt+'') : txt+'';
	};
}

function round(num, decimalPlaces = 2) {
  return Number(num.toFixed(decimalPlaces));
}

const s = 1e3;
const m = s * 60;
const h = m * 60;
const d = h * 24;
function ms(val) {
  const msAbs = Math.abs(val);
  if (msAbs >= d) {
    return Math.round(val / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(val / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(val / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(val / s) + "s";
  }
  return round(val, 2) + "ms";
}

var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["Silent"] = 0] = "Silent";
  LogLevel2[LogLevel2["Error"] = 1] = "Error";
  LogLevel2[LogLevel2["Warn"] = 2] = "Warn";
  LogLevel2[LogLevel2["Info"] = 3] = "Info";
  LogLevel2[LogLevel2["Verbose"] = 4] = "Verbose";
  return LogLevel2;
})(LogLevel || {});
const LogLevelColor = Object.freeze({
  [0 /* Silent */]: $.bgWhite,
  [1 /* Error */]: $.bgRed,
  [2 /* Warn */]: $.bgYellow,
  [3 /* Info */]: $.bgCyan,
  [4 /* Verbose */]: $.bgMagenta
});
let currentLogLevel = 3 /* Info */;
function mapLogLevelStringToNumber(level) {
  switch (level) {
    case "silent":
      return 0 /* Silent */;
    case "error":
      return 1 /* Error */;
    case "warn":
      return 2 /* Warn */;
    case "info":
      return 3 /* Info */;
    case "verbose":
      return 4 /* Verbose */;
    default:
      return 3 /* Info */;
  }
}
function mapLogLevelToString(level) {
  switch (level) {
    case 1 /* Error */:
      return "error";
    case 2 /* Warn */:
      return "warn";
    case 3 /* Info */:
      return "info";
    case 4 /* Verbose */:
      return "verbose";
    case 0 /* Silent */:
      return "silent";
    default:
      return "info";
  }
}
const clearTerminal = () => {
  console.clear();
};
function setGlobalLogLevel(level) {
  currentLogLevel = level;
}
const log = (text, level = 3 /* Info */) => {
  if (currentLogLevel < level)
    return;
  if (isFunction(text)) {
    text = text();
  }
  if (isObject(text)) {
    console.dir(text, { depth: 10 });
  } else {
    const currentColor = LogLevelColor[level];
    console.log(
      $.dim(
        `${formatPluginName("maverick")} ${currentColor(
          $.bold($.black(` ${mapLogLevelToString(level).toUpperCase()} `))
        )}`
      ),
      `${text}
`
    );
  }
};
const logTime = (message, startTime, level = 3 /* Info */) => {
  const totalTime = process.hrtime(startTime);
  const totalTimeText = $.green(ms(totalTime[0] * 1e3 + totalTime[1] / 1e6));
  log(() => `${message} in ${totalTimeText}.`, level);
};
function formatPluginName(name) {
  return `[${name.startsWith("maverick") ? $.dim(name) : $.yellow(name)}]`;
}
const logStackTrace = (message, stack, level = 1 /* Error */) => {
  log(
    `

${$.bold("MESSAGE")}

${message}

${$.bold("STACK TRACE")}

${stack}`,
    level
  );
};
const printDiagnostic = (message, sourceFilePath, sourceText, startLineNumber, endLineNumber, level) => {
  log(
    printDiagnosticOutput(message, sourceFilePath, sourceText, startLineNumber, endLineNumber),
    level
  );
};
function printDiagnosticOutput(message, sourceFilePath, sourceText, startLineNumber, endLineNumber) {
  const isMultiLine = endLineNumber - startLineNumber > 0;
  const codeFrame = buildCodeFrame(sourceText, startLineNumber, endLineNumber);
  return [
    `

${$.bold("MESSAGE")}`,
    `
${message}`,
    `
${$.bold("CODE")}
`,
    `${$.dim(sourceFilePath)} ${$.dim("L:")}${$.dim(
      isMultiLine ? `${startLineNumber}-${endLineNumber}` : startLineNumber
    )}
`,
    prettifyCodeFrame(codeFrame)
  ].join("\n");
}
const reportDiagnosticByNode = (message, node, level = 3 /* Info */) => {
  if (!node)
    return;
  const sourceFile = node.getSourceFile();
  const sourceFilePath = normalize$1(sourceFile.fileName);
  const sourceText = sourceFile.text;
  const posStart = sourceFile.getLineAndCharacterOfPosition(node.getStart());
  const posEnd = sourceFile.getLineAndCharacterOfPosition(node.getEnd());
  const startLineNumber = posStart.line + 1;
  const endLineNumber = posEnd.line + 1;
  {
    printDiagnostic(message, sourceFilePath, sourceText, startLineNumber, endLineNumber, level);
  }
};
function prettifyCodeFrame(codeFrame) {
  const { firstLineNumber, linesBefore, relevantLines, linesAfter } = codeFrame;
  const printLines = [];
  const maxNoOfDigits = (firstLineNumber + codeFrame.totalLines).toString().length;
  const formatLineNumber = (lineNumber) => {
    const missingDigits = maxNoOfDigits - lineNumber.toString().length;
    return missingDigits > 0 ? `${" ".repeat(missingDigits)}${lineNumber}` : `${lineNumber}`;
  };
  const printLine = (line, lineNumber, isRelevant = false) => (isRelevant ? $.white : $.dim)(
    `${isRelevant ? "> " : "  "}${$.bold(formatLineNumber(lineNumber))} |  ${line}`
  );
  linesBefore.forEach((line, i) => {
    printLines.push(printLine(line, firstLineNumber + i));
  });
  relevantLines.forEach((line, i) => {
    printLines.push(printLine(line, firstLineNumber + linesBefore.length + i, true));
  });
  linesAfter.forEach((line, i) => {
    printLines.push(
      printLine(line, firstLineNumber + linesBefore.length + relevantLines.length + i)
    );
  });
  return printLines.join("\n");
}
function buildCodeFrame(sourceText, startLineNumber, endLineNumber, frameSize = 5) {
  const startLineNumberMinusOne = startLineNumber - 1;
  const lines = splitLineBreaks(sourceText);
  const startAt = startLineNumberMinusOne - frameSize < 0 ? 0 : startLineNumberMinusOne - frameSize;
  const endAt = endLineNumber + frameSize > lines.length ? lines.length : endLineNumber + frameSize;
  const codeFrame = {
    firstLineNumber: startAt + 1,
    linesBefore: [],
    relevantLines: [],
    linesAfter: [],
    totalLines: 0
  };
  let lineCounter = 0;
  const MAX_LINES = 15;
  function buildLines(start, end) {
    if (lineCounter > MAX_LINES - 1)
      return [];
    const newLines = [];
    for (let i = start; i < end; i++) {
      if (lines[i] != null) {
        newLines.push(lines[i]);
        lineCounter += 1;
      }
      if (lineCounter > MAX_LINES - 1) {
        return newLines;
      }
    }
    return newLines;
  }
  codeFrame.linesBefore = buildLines(startAt, startLineNumberMinusOne);
  codeFrame.relevantLines = buildLines(startLineNumberMinusOne, endLineNumber);
  codeFrame.linesAfter = buildLines(endLineNumber, endAt + 1);
  const linesHidden = endAt - startAt - lineCounter;
  if (linesHidden > 0) {
    codeFrame.linesAfter.push(
      $.dim(`${linesHidden} ${linesHidden === 1 ? "line" : "lines"} hidden...`)
    );
  }
  codeFrame.totalLines = lineCounter;
  return codeFrame;
}

function getDeclarations(checker, identifier) {
  if (identifier.parent && (ts.isImportClause(identifier.parent) || ts.isImportSpecifier(identifier.parent))) {
    const symbol = checker.getSymbolAtLocation(identifier);
    return symbol ? checker.getAliasedSymbol(symbol)?.declarations : void 0;
  } else {
    const declarations = checker.getSymbolAtLocation(identifier)?.declarations;
    const declaration = declarations?.[0];
    if (declaration && (ts.isImportClause(declaration) || ts.isImportSpecifier(declaration)) && declaration.name && ts.isIdentifier(declaration.name)) {
      const symbol = checker.getSymbolAtLocation(declaration.name);
      return symbol ? checker.getAliasedSymbol(symbol)?.declarations : void 0;
    }
    return declarations;
  }
}
function getDeclaration(checker, identifier) {
  return getDeclarations(checker, identifier)?.[0];
}
function getShorthandAssignmentDeclaration(checker, node) {
  const symbol = checker.getShorthandAssignmentValueSymbol(node);
  const declaration = symbol?.declarations?.[0];
  return declaration?.name && ts.isIdentifier(declaration.name) ? getDeclaration(checker, declaration.name) : void 0;
}

function getProperties(checker, node) {
  const props = /* @__PURE__ */ new Map();
  for (const symbol of checker.getPropertiesOfType(checker.getTypeAtLocation(node))) {
    const declaration = symbol.declarations?.[0];
    if (declaration && ts.isPropertyAssignment(declaration)) {
      props.set(escapeQuotes(declaration.name.getText()), declaration);
    }
  }
  return props;
}
function getPropertiesAndGetters(checker, node) {
  const props = /* @__PURE__ */ new Map();
  if (node && ts.isIdentifier(node)) {
    node = getDeclaration(checker, node);
  }
  if (node && ts.isVariableDeclaration(node)) {
    node = node.initializer;
  }
  if (!node)
    return props;
  for (const symbol of checker.getPropertiesOfType(checker.getTypeAtLocation(node))) {
    const declaration = symbol.declarations?.[0];
    if (declaration && (ts.isPropertyAssignment(declaration) || ts.isGetAccessorDeclaration(declaration))) {
      props.set(escapeQuotes(declaration.name.getText()), declaration);
    }
  }
  return props;
}
function walkTypeHeritage(checker, node, visitor) {
  if (ts.isIdentifier(node)) {
    const declaration = getDeclaration(checker, node);
    if (declaration)
      walkTypeHeritage(checker, declaration, visitor);
  } else if (ts.isTypeReferenceNode(node)) {
    const stop = visitor.typeReference?.(node);
    if (stop)
      return;
    walkTypeHeritage(checker, node.typeName, visitor);
  } else if (ts.isInterfaceDeclaration(node)) {
    const stop = visitor.interface?.(node);
    if (stop)
      return;
    if (node.heritageClauses) {
      for (const clause of node.heritageClauses) {
        const stop2 = visitor.heritageClause?.(clause);
        if (stop2)
          return;
        const id = clause.types[0].expression;
        walkTypeHeritage(checker, id, visitor);
      }
    }
  } else if (ts.isTypeAliasDeclaration(node)) {
    const stop = visitor.typeAlias?.(node);
    if (stop)
      return;
    if (ts.isIntersectionTypeNode(node.type)) {
      for (const type of node.type.types) {
        walkTypeHeritage(checker, type, visitor);
      }
    }
  } else if (ts.isTypeLiteralNode(node)) {
    const stop = visitor.typeLiteral?.(node);
    if (stop)
      return;
  } else if (ts.isExpressionWithTypeArguments(node) && node.typeArguments) {
    for (const arg of node.typeArguments)
      walkTypeHeritage(checker, arg, visitor);
  }
}
function getHeritage(checker, node) {
  const classes = /* @__PURE__ */ new Map(), mixins = /* @__PURE__ */ new Map();
  while (node) {
    if (node.name)
      classes.set(node.name.getText(), node);
    if (!node.heritageClauses)
      break;
    for (const clause of node.heritageClauses) {
      let expression = clause.types[0]?.expression, identifier = expression;
      if (ts.isCallExpression(expression)) {
        identifier = expression.expression;
      }
      if (!identifier || !ts.isIdentifier(identifier)) {
        node = null;
        continue;
      }
      if (ts.isCallExpression(expression) && expression.arguments[0] && ts.isIdentifier(expression.arguments[0])) {
        mixins.set(identifier.getText(), expression);
        const declaration2 = getDeclaration(checker, expression.arguments[0]);
        if (declaration2 && ts.isClassDeclaration(declaration2)) {
          node = declaration2;
        } else {
          node = null;
        }
        continue;
      }
      const declaration = getDeclaration(checker, identifier);
      if (!declaration || !ts.isClassDeclaration(declaration)) {
        node = null;
        continue;
      }
      node = declaration;
      break;
    }
  }
  return { classes, mixins };
}
function getValueNode(checker, node) {
  if (node) {
    if (ts.isIdentifier(node)) {
      return getValueNode(checker, getDeclaration(checker, node));
    } else if (ts.isShorthandPropertyAssignment(node)) {
      return getValueNode(checker, getShorthandAssignmentDeclaration(checker, node));
    } else if (ts.isVariableDeclaration(node) || ts.isPropertyAssignment(node)) {
      return getValueNode(checker, node.initializer);
    } else if (ts.isPropertyAccessExpression(node)) {
      return ts.isIdentifier(node.name) ? getDeepValueNode(checker, node.name) : node;
    }
  }
  return node;
}
function getDeepValueNode(checker, node) {
  if (node) {
    if (ts.isIdentifier(node)) {
      return getDeepValueNode(checker, getDeclaration(checker, node));
    } else if (ts.isVariableDeclaration(node) || ts.isPropertyAssignment(node)) {
      return getDeepValueNode(checker, node.initializer);
    } else if (ts.isPropertyAccessExpression(node)) {
      return ts.isIdentifier(node.name) ? getDeepValueNode(checker, node.name) : node;
    } else if (ts.isShorthandPropertyAssignment(node)) {
      return getDeepValueNode(checker, getShorthandAssignmentDeclaration(checker, node));
    } else if (ts.isCallExpression(node)) {
      return getDeepValueNode(checker, node.expression);
    } else if (ts.isFunctionDeclaration(node) || ts.isArrowFunction(node) && ts.isBlock(node.body)) {
      const returnStatement = getReturnStatement(node);
      return returnStatement ? getDeepValueNode(checker, returnStatement.expression) : node.body;
    } else if (ts.isArrowFunction(node)) {
      const body = ts.isParenthesizedExpression(node.body) ? node.body.expression : node.body;
      return getDeepValueNode(checker, body);
    }
  }
  return node;
}
function getReturnStatement(node) {
  if (!node)
    return void 0;
  return node.body?.statements.find(
    (statement) => ts.isReturnStatement(statement)
  );
}
function getReturnExpression(node) {
  if (!node)
    return void 0;
  return ts.isArrowFunction(node) && !ts.isBlock(node.body) ? ts.isParenthesizedExpression(node.body) ? node.body.expression : node.body : ts.isMethodDeclaration(node) || ts.isFunctionDeclaration(node) || ts.isArrowFunction(node) && ts.isBlock(node.body) ? getReturnStatement(node)?.expression : void 0;
}

function buildAttrsMeta(checker, staticProp) {
  if (!staticProp)
    return void 0;
  const attrs = {}, props = getProperties(checker, staticProp.initializer);
  for (const [propName, assignment] of props) {
    let attr = assignment.initializer;
    if (ts.isObjectLiteralExpression(attr)) {
      attr = getProperties(checker, attr).get("attr")?.initializer;
    }
    if (attr && attr.kind !== ts.SyntaxKind.StringLiteral && attr.kind !== ts.SyntaxKind.FalseKeyword) {
      reportDiagnosticByNode("expected string or false", assignment, LogLevel.Warn);
      continue;
    }
    if (attr) {
      attrs[propName] = {
        [TS_NODE]: assignment,
        attr: ts.isStringLiteral(attr) ? escapeQuotes(attr.getText()) : false
      };
    }
  }
  return Object.keys(attrs).length ? attrs : void 0;
}

function splitJsDocTagText(tag) {
  const [title, description] = (tag.text?.split(" - ") ?? []).map((s) => s.trim());
  return {
    [TS_NODE]: tag[TS_NODE],
    title: !description ? void 0 : title,
    description: !description ? title : description
  };
}
function resolveDocTagText(node, text) {
  if (typeof text === "object") {
    text = text.find((text2) => !!text2.name).text;
    return text?.startsWith("://") ? `https${text}` : text;
  }
  if (!text || !/^('|")?(\.\/|\.\.\/)/.test(text ?? ""))
    return text;
  const filePath = normalize$1(node.getSourceFile().fileName);
  const textPath = escapeQuotes(text);
  return resolve$1(dirname$1(filePath), textPath);
}
const getDocTags = (node) => {
  if (!node)
    return void 0;
  const tags = node.jsDoc?.[0]?.tags;
  return tags?.map((docTagNode) => ({
    [TS_NODE]: docTagNode,
    name: docTagNode.tagName.escapedText,
    text: resolveDocTagText(node, docTagNode.comment)
  }));
};
const findDocTag = (tags, name) => tags.find((tag) => tag.name === name);
const hasDocTag = (tags, name) => tags.some((tag) => tag.name === name);
function buildMetaFromDocTags(doctags, tagName, example) {
  const tags = doctags.filter((tag) => tag.name === tagName).map((tag) => splitJsDocTagText(tag));
  return filterArrayUnique(tags, "title", {
    onDuplicateFound: (tag) => {
      reportDiagnosticByNode(
        `Found duplicate \`@${tagName}\` tags with the name \`${tag.title}\`.`,
        tag[TS_NODE],
        LogLevel.Warn
      );
    }
  }).map((tag) => {
    if (!tag.title) {
      reportDiagnosticByNode(
        [
          `Tag \`@${tagName}\` is missing a title.`,
          `
${$.bold("EXAMPLE")}

${example}`
        ].join("\n"),
        tag[TS_NODE],
        LogLevel.Warn
      );
    }
    if (tag.title && !tag.description) {
      reportDiagnosticByNode(
        [
          `Tag \`@${tagName}\` is missing a description.`,
          `
${$.bold("EXAMPLE")}

${example}`
        ].join("\n"),
        tag[TS_NODE],
        LogLevel.Warn
      );
    }
    return {
      [TS_NODE]: tag[TS_NODE],
      name: tag.title ?? "",
      description: tag.description ?? ""
    };
  });
}

function buildCSSPartsMeta(doctags) {
  if (!doctags)
    return void 0;
  const cssParts = buildMetaFromDocTags(
    doctags,
    "csspart",
    "@csspart container - The root container of this component."
  );
  return cssParts.length > 0 ? cssParts : void 0;
}

function getDocs(checker, id) {
  const comment = checker.getSymbolAtLocation(id)?.getDocumentationComment(checker);
  const str = ts.displayPartsToString(comment);
  return str ? normalizeLineBreaks(str) : void 0;
}

const CONCISE_TYPE_FORMAT_FLAGS = ts.TypeFormatFlags.UseSingleQuotesForStringLiteralType | ts.TypeFormatFlags.NoTruncation | ts.TypeFormatFlags.InElementType;
const FULL_TYPE_FORMAT_FLAGS = ts.TypeFormatFlags.UseSingleQuotesForStringLiteralType | ts.TypeFormatFlags.NoTypeReduction | ts.TypeFormatFlags.NoTruncation | ts.TypeFormatFlags.InTypeAlias | ts.TypeFormatFlags.UseAliasDefinedOutsideCurrentScope;
function buildTypeMeta(checker, type) {
  return {
    primitive: resolvePrimitiveType(type),
    concise: serializeType(checker, type, CONCISE_TYPE_FORMAT_FLAGS),
    full: serializeType(checker, type, FULL_TYPE_FORMAT_FLAGS)
  };
}
function serializeType(checker, type, flags = CONCISE_TYPE_FORMAT_FLAGS) {
  return checker.typeToString(type, void 0, flags);
}
function resolvePrimitiveType(type) {
  if (isNeverType(type)) {
    return "never";
  } else if (isAnyType(type)) {
    return "any";
  } else if (isSymbolType(type)) {
    return "symbol";
  } else if (isUnknownType(type)) {
    return "unknown";
  } else if (type.getCallSignatures().length) {
    return "function";
  }
  const str = isType(type, isStringType), num = isType(type, isNumberType), bool = isType(type, isBooleanType);
  if (str && num && bool)
    return "mixed";
  else if (str && num)
    return "mixed";
  else if (str && bool)
    return "mixed";
  else if (num && bool)
    return "mixed";
  else if (str)
    return "string";
  else if (num)
    return "number";
  else if (bool)
    return "boolean";
  if (isType(type, isObjectType)) {
    return "object";
  }
  return "unknown";
}
function isType(type, is) {
  return type.isUnion() ? type.types.some((t) => isType(t, is)) : is(type);
}
const BOOLEAN_FLAGS = ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLike;
function isBooleanType(t) {
  return (t.flags & BOOLEAN_FLAGS) > 0;
}
const NUMBER_FLAGS = ts.TypeFlags.Number | ts.TypeFlags.NumberLike | ts.TypeFlags.NumberLiteral;
function isNumberType(t) {
  return (t.flags & NUMBER_FLAGS) > 0;
}
const STRING_FLAGS = ts.TypeFlags.String | ts.TypeFlags.StringLike | ts.TypeFlags.StringLiteral;
function isStringType(t) {
  return (t.flags & STRING_FLAGS) > 0;
}
const SYMBOL_FLAGS = ts.TypeFlags.ESSymbol | ts.TypeFlags.ESSymbolLike | ts.TypeFlags.UniqueESSymbol;
function isSymbolType(t) {
  return (t.flags & SYMBOL_FLAGS) > 0;
}
const OBJECT_FLAGS = ts.TypeFlags.Object;
function isObjectType(t) {
  return (t.flags & OBJECT_FLAGS) > 0;
}
function isAnyType(t) {
  return (t.flags & ts.TypeFlags.Any) > 0;
}
function isNeverType(t) {
  return (t.flags & ts.TypeFlags.Never) > 0;
}
function isUnknownType(t) {
  return (t.flags & ts.TypeFlags.Unknown) > 0;
}

const filteredTagNames$2 = /* @__PURE__ */ new Set([
  "internal",
  "required",
  "deprecated",
  "default",
  "defaultValue",
  "optional",
  "readonly"
]);
function buildCSSVarsMeta(checker, typeRoot, parentDocTags) {
  const meta = /* @__PURE__ */ new Map();
  if (parentDocTags?.length) {
    const cssvars = buildMetaFromDocTags(
      parentDocTags,
      "cssvar",
      "@cssvar --bg-color - The background color of this component."
    );
    for (const cssvar of cssvars) {
      meta.set(cssvar.name, cssvar);
    }
  }
  if (typeRoot) {
    for (const symbol of checker.getPropertiesOfType(typeRoot)) {
      const signature = symbol.declarations?.[0];
      if (!signature || !ts.isPropertySignature(signature) || !signature.name)
        continue;
      const name = escapeQuotes(signature.name.getText()), docs = getDocs(checker, signature.name), doctags = getDocTags(signature), filteredDoctags = doctags?.filter((tag) => !filteredTagNames$2.has(tag.name)), type = buildTypeMeta(checker, checker.getTypeOfSymbol(symbol));
      let internal, required, deprecated, $default, optional = !!signature.questionToken, readonly = !!signature.modifiers?.some(
        (mod) => mod.kind === ts.SyntaxKind.ReadonlyKeyword
      );
      if (doctags) {
        if (hasDocTag(doctags, "internal"))
          internal = true;
        if (hasDocTag(doctags, "deprecated"))
          deprecated = true;
        if (hasDocTag(doctags, "required"))
          required = true;
        if (!readonly && hasDocTag(doctags, "readonly"))
          readonly = true;
        if (!optional && hasDocTag(doctags, "optional"))
          optional = true;
        $default = findDocTag(doctags, "default")?.text ?? findDocTag(doctags, "defaultValue")?.text ?? "";
      }
      meta.set(name, {
        [TS_NODE]: signature,
        name,
        default: $default,
        type,
        docs,
        doctags: filteredDoctags?.length ? filteredDoctags : void 0,
        internal,
        deprecated,
        readonly: readonly ? true : void 0,
        optional: optional ? true : void 0,
        required
      });
    }
  }
  return meta.size > 0 ? Array.from(meta.values()) : void 0;
}

const filteredTagNames$1 = /* @__PURE__ */ new Set(["internal", "deprecated", "bubbles", "composed", "cancellable"]);
function buildEventsMeta(checker, typesRoot) {
  if (!typesRoot)
    return;
  const meta = /* @__PURE__ */ new Map();
  for (const symbol of checker.getPropertiesOfType(typesRoot)) {
    const signature = symbol.declarations?.[0];
    if (!signature || !ts.isPropertySignature(signature) || !signature.name)
      continue;
    const name = escapeQuotes(signature.name.getText()), isTypeReference = signature.type && ts.isTypeReferenceNode(signature.type) && ts.isIdentifier(signature.type.typeName), declaration = isTypeReference ? getDeclaration(checker, signature.type.typeName) : void 0, docs = getDocs(checker, signature.name) ?? (isTypeReference ? getDocs(checker, signature.type.typeName) : void 0), doctags = getDocTags(signature) ?? (isTypeReference ? getDocTags(declaration) : void 0), filteredDoctags = doctags?.filter((tag) => !filteredTagNames$1.has(tag.name)), type = buildTypeMeta(checker, checker.getTypeOfSymbol(symbol));
    let internal, deprecated, bubbles, composed, cancellable;
    const detailType = signature.type ? checker.getPropertyOfType(checker.getTypeAtLocation(signature.type), "detail") : null, detail = detailType && detailType.declarations?.[0] ? buildTypeMeta(
      checker,
      checker.getTypeOfSymbolAtLocation(detailType, detailType.declarations[0])
    ) : {
      concise: "unknown",
      primitive: "unknown",
      full: "unknown"
    };
    if (doctags) {
      if (hasDocTag(doctags, "internal"))
        internal = true;
      if (hasDocTag(doctags, "deprecated"))
        deprecated = true;
      if (hasDocTag(doctags, "bubbles"))
        bubbles = true;
      if (hasDocTag(doctags, "composed"))
        composed = true;
      if (hasDocTag(doctags, "cancellable"))
        cancellable = true;
    }
    meta.set(name, {
      [TS_NODE]: signature,
      name,
      type,
      detail,
      docs,
      doctags: filteredDoctags?.length ? filteredDoctags : void 0,
      bubbles,
      composed,
      cancellable,
      internal,
      deprecated
    });
  }
  return meta.size > 0 ? Array.from(meta.values()) : void 0;
}

function buildFileMeta(node) {
  const file = node.getSourceFile();
  return {
    [TS_NODE]: file,
    path: normalize$1(file.fileName)
  };
}

function buildGenericsMeta(checker, props, state, events) {
  const propsGeneric = props ? serializeType(checker, props) : void 0, stateGeneric = state ? serializeType(checker, state) : void 0, eventsGeneric = events ? serializeType(checker, events) : void 0, hasGenerics = isValidGeneric(propsGeneric) || isValidGeneric(stateGeneric) || isValidGeneric(eventsGeneric);
  return hasGenerics ? {
    props: isValidGeneric(propsGeneric) ? propsGeneric : void 0,
    state: isValidGeneric(stateGeneric) ? stateGeneric : void 0,
    events: isValidGeneric(eventsGeneric) ? eventsGeneric : void 0
  } : void 0;
}
function isValidGeneric(type) {
  return !!type && type !== "{}" && !type.includes(" ");
}

function buildMethodMeta(checker, name, declaration, info) {
  const docs = getDocs(checker, declaration.name), doctags = getDocTags(declaration), signature = checker.getSignatureFromDeclaration(declaration), returnType = checker.getReturnTypeOfSignature(signature);
  const parameters = declaration.parameters.filter((parameter) => parameter.type).map((parameter) => ({
    [TS_NODE]: parameter,
    name: parameter.name.escapedText,
    type: buildTypeMeta(checker, checker.getTypeAtLocation(parameter)),
    optional: !isUndefined(parameter.questionToken) ? true : void 0,
    default: parameter.initializer?.getText()
  }));
  let internal, deprecated;
  if (doctags) {
    if (hasDocTag(doctags, "internal"))
      internal = true;
    if (hasDocTag(doctags, "deprecated"))
      deprecated = true;
  }
  return {
    [TS_NODE]: declaration,
    name,
    docs,
    doctags,
    internal,
    deprecated,
    parameters,
    signature: {
      [TS_NODE]: signature,
      type: checker.signatureToString(
        signature,
        declaration,
        ts.TypeFormatFlags.WriteArrowStyleSignature | ts.TypeFormatFlags.NoTruncation,
        ts.SignatureKind.Call
      )
    },
    return: {
      [TS_NODE]: returnType,
      type: serializeType(checker, returnType)
    }
  };
}

function buildPropsMeta(checker, staticProp, typeRoot) {
  if (!typeRoot)
    return;
  const meta = [], propTypes = checker.getPropertiesOfType(typeRoot);
  if (propTypes.length > 0) {
    const values = staticProp?.initializer ? getPropertiesAndGetters(checker, staticProp.initializer) : null;
    for (const symbol of propTypes) {
      const signature = symbol.declarations?.[0];
      if (!signature || !ts.isPropertySignature(signature)) {
        continue;
      }
      const name = escapeQuotes(signature.name.getText()), type = checker.getTypeOfSymbol(symbol), value = values?.get(name);
      let info = {
        type
      };
      if (value) {
        info.value = ts.isPropertyAssignment(value) ? value.initializer.getText() : value.getText();
      }
      const propMeta = buildPropMeta(checker, name, signature, info);
      if (propMeta)
        meta.push(propMeta);
    }
  }
  return meta.length > 0 ? meta : void 0;
}
const filteredTagNames = /* @__PURE__ */ new Set([
  "readonly",
  "internal",
  "deprecated",
  "required",
  "default",
  "defaultValue"
]);
function buildPropMeta(checker, name, node, info) {
  const identifier = node?.name, symbol = identifier ? checker.getSymbolAtLocation(identifier) : void 0, isGetAccessor = node && ts.isGetAccessor(node), hasSetAccessor = node && ts.isGetAccessor(node) ? !!symbol?.declarations.some(ts.isSetAccessorDeclaration) : void 0, docs = identifier ? getDocs(checker, identifier) : void 0, doctags = node ? getDocTags(node) : void 0, filteredDoctags = doctags?.filter((tag) => !filteredTagNames.has(tag.name)), readonly = !!node?.modifiers?.some(
    (mode) => mode.kind === ts.SyntaxKind.ReadonlyKeyword
  ) || isGetAccessor && !hasSetAccessor || !hasSetAccessor && doctags && hasDocTag(doctags, "readonly");
  let { internal, required, deprecated, defaultValue } = resolvePropTags(doctags);
  if (!defaultValue && info?.value) {
    defaultValue = info.value;
  }
  if (!defaultValue && ts.isPropertyDeclaration(node) && node.initializer) {
    defaultValue = node.initializer.getText();
  }
  return {
    [TS_NODE]: node,
    name,
    default: defaultValue?.length ? defaultValue : void 0,
    type: buildTypeMeta(checker, info.type),
    docs,
    doctags: filteredDoctags?.length ? filteredDoctags : void 0,
    required,
    readonly: readonly ? true : void 0,
    internal,
    deprecated
  };
}
function resolvePropTags(doctags) {
  let internal, deprecated, required, defaultValue;
  if (doctags) {
    if (hasDocTag(doctags, "internal"))
      internal = true;
    if (hasDocTag(doctags, "deprecated"))
      deprecated = true;
    if (hasDocTag(doctags, "required"))
      required = true;
    defaultValue = findDocTag(doctags, "default")?.text ?? findDocTag(doctags, "defaultValue")?.text ?? "";
  }
  return {
    internal,
    deprecated,
    required,
    defaultValue
  };
}

function buildMembersMeta(checker, root, stateDeclaration, stateType) {
  const props = [], methods = [];
  for (const symbol of checker.getPropertiesOfType(root)) {
    const declaration = symbol.declarations?.[0];
    if (!declaration)
      continue;
    if (ts.isPropertyDeclaration(declaration) || ts.isGetAccessorDeclaration(declaration)) {
      const name = escapeQuotes(declaration.name.getText());
      if (ignoreMember(name, declaration))
        continue;
      props.push(
        buildPropMeta(checker, name, declaration, {
          type: checker.getTypeOfSymbol(symbol)
        })
      );
    } else if (ts.isMethodDeclaration(declaration)) {
      const name = escapeQuotes(declaration.name.getText());
      if (ignoreMember(name, declaration))
        continue;
      methods.push(
        buildMethodMeta(checker, name, declaration, {
          type: checker.getTypeOfSymbol(symbol)
        })
      );
    }
  }
  if (stateType && stateDeclaration) {
    const type = buildTypeMeta(checker, stateType);
    props.push({
      [TS_NODE]: stateDeclaration,
      name: "state",
      docs: "This object contains the current state of the component.",
      type,
      readonly: true
    });
    methods.push({
      [TS_NODE]: stateDeclaration,
      name: "subscribe",
      docs: "Subscribe to live updates of component state.",
      parameters: [
        {
          name: "callback",
          type: {
            primitive: "function",
            concise: `Effect<${type.concise}>`,
            full: `(state: ${type.concise}) => Maybe<Dispose>`
          }
        }
      ],
      signature: { type: `(callback: Effect<${type.concise}>) => Unsubscribe` },
      return: { type: "Unsubscribe" }
    });
  }
  return props.length > 0 || methods.length > 0 ? {
    props: props.length > 0 ? props : void 0,
    methods: methods.length > 0 ? methods : void 0,
    length: props.length + methods.length
  } : void 0;
}
const validDecoratorName = /^prop|method$/, ignoredName = /* @__PURE__ */ new Set([
  "$",
  "$$",
  "scope",
  "attachScope",
  "connectScope",
  "el",
  "$el",
  "$props",
  "state",
  "$state",
  "subscribe",
  "attach",
  "render",
  "destroy",
  "onSetup",
  "onAttach",
  "onConnect",
  "onDestroy",
  "createEvent",
  "listen",
  "dispatch",
  "dispatchEvent",
  "addEventListener",
  "removeEventListener"
]), decoratorWarnings = /* @__PURE__ */ new Set();
function ignoreMember(name, node) {
  if (ignoredName.has(name))
    return true;
  const isPublic = (!node.modifiers || !node.modifiers.some(
    (m) => m.kind === ts.SyntaxKind.ProtectedKeyword || m.kind === ts.SyntaxKind.PrivateKeyword
  )) && node.name.kind !== ts.SyntaxKind.PrivateIdentifier;
  const hasDecorator = isPublic && node.modifiers && node.modifiers.some(
    (modifier) => modifier.kind === ts.SyntaxKind.Decorator && ts.isIdentifier(modifier.expression) && validDecoratorName.test(modifier.expression.escapedText)
  );
  if (isPublic && !hasDecorator && !decoratorWarnings.has(node) && !name.startsWith("_")) {
    const isMethod = ts.isMethodDeclaration(node);
    reportDiagnosticByNode(
      `Public ${isMethod ? "method" : "property"} \`${name}\` requires \`${isMethod ? "@method" : "@prop"}\` decorator`,
      node
    );
    decoratorWarnings.add(node);
  }
  return !isPublic || !hasDecorator;
}

function buildPartsMeta(doctags) {
  if (!doctags)
    return void 0;
  const parts = buildMetaFromDocTags(
    doctags,
    "part",
    "@part container - The root container of this component."
  );
  return parts.length > 0 ? parts : void 0;
}

function buildSlotsMeta(doctags) {
  if (!doctags)
    return void 0;
  let defaultSlots = 0;
  let hasSeenDefaultSlot = false;
  const slots = doctags.filter((tag) => tag.name === "slot").map((tag) => splitJsDocTagText(tag));
  const filtered = filterArrayUnique(slots, "title", {
    onDuplicateFound: (slot) => {
      reportDiagnosticByNode(
        `Found duplicate \`@slot\` tags with the name \`${slot.title}\`.`,
        slot[TS_NODE],
        LogLevel.Warn
      );
    }
  }).map((slot) => {
    const isDefaultSlot = !slot.title;
    if (isDefaultSlot && hasSeenDefaultSlot) {
      reportDiagnosticByNode(
        [
          "Non default `@slot` tag is missing a title.",
          `
${$.bold("EXAMPLE")}

@slot body - Used to pass in the body of this component.`
        ].join("\n"),
        slot[TS_NODE],
        LogLevel.Warn
      );
    }
    if (isDefaultSlot) {
      defaultSlots += 1;
      hasSeenDefaultSlot = true;
    }
    return {
      [TS_NODE]: slot[TS_NODE],
      name: isDefaultSlot && defaultSlots === 1 ? void 0 : slot.title ?? "",
      docs: slot.description.replace(/^-\s/, "") ?? ""
    };
  });
  return filtered.length > 0 ? filtered : void 0;
}

function buildStateMeta(checker, staticProp, typeRoot) {
  if (!typeRoot)
    return;
  const meta = [], propTypes = checker.getPropertiesOfType(typeRoot);
  if (propTypes.length > 0) {
    const factory = staticProp?.initializer && getValueNode(checker, staticProp.initializer), stateArg = factory && ts.isNewExpression(factory) && factory.arguments?.[0], values = stateArg ? getPropertiesAndGetters(checker, stateArg) : null;
    for (const symbol of propTypes) {
      const signature = symbol.declarations?.[0];
      if (!signature || !ts.isPropertySignature(signature))
        continue;
      const name = escapeQuotes(signature.name.getText()), type = checker.getTypeOfSymbol(symbol), value = values?.get(name), docs = getDocs(checker, signature.name), doctags = getDocTags(signature), filteredDoctags = doctags?.filter(
        (tag) => tag.name !== "readonly" && tag.name !== "deprecated"
      ), readonly = value && ts.isGetAccessorDeclaration(value) || !!signature?.modifiers?.some((mode) => mode.kind === ts.SyntaxKind.ReadonlyKeyword) || doctags && hasDocTag(doctags, "readonly"), internal = doctags && hasDocTag(doctags, "internal"), deprecated = doctags && hasDocTag(doctags, "deprecated"), defaultValue = value && ts.isPropertyAssignment(value) ? value.initializer.getText() : void 0;
      meta.push({
        [TS_NODE]: signature,
        name,
        type: buildTypeMeta(checker, type),
        docs,
        doctags: filteredDoctags?.length ? filteredDoctags : void 0,
        default: defaultValue,
        readonly: readonly ? true : void 0,
        internal: internal ? true : void 0,
        deprecated: deprecated ? true : void 0
      });
    }
  }
  return meta.length ? meta : void 0;
}

function createBuildPlugin() {
  let checker;
  return {
    name: "maverick/build",
    async init(program) {
      checker = program.getTypeChecker();
    },
    async buildComponentMeta(node) {
      let doctags = getDocTags(node.root), filteredDoctags = doctags?.filter((tag) => tag.name !== "cssvar" && tag.name !== "part");
      return {
        [TS_NODE]: node.root,
        type: "component",
        name: node.name,
        file: buildFileMeta(node.root),
        docs: getDocs(checker, node.root.name),
        doctags: filteredDoctags?.length ? filteredDoctags : void 0,
        props: buildPropsMeta(checker, node.props, node.types.props),
        events: buildEventsMeta(checker, node.types.events),
        parts: buildPartsMeta(doctags),
        cssvars: buildCSSVarsMeta(checker, node.types.cssvars, doctags),
        state: buildStateMeta(checker, node.state, node.types.state),
        members: buildMembersMeta(checker, node.types.root, node.state, node.types.state),
        generics: buildGenericsMeta(checker, node.types.props, node.types.state, node.types.events)
      };
    },
    async buildCustomElementMeta(node) {
      let doctags = getDocTags(node.root), filteredDoctags = doctags?.filter((tag) => tag.name !== "slot" && tag.name !== "csspart");
      return {
        [TS_NODE]: node.root,
        type: "element",
        file: buildFileMeta(node.root),
        name: node.name,
        docs: getDocs(checker, node.root.name),
        doctags: filteredDoctags?.length ? filteredDoctags : void 0,
        tag: {
          [TS_NODE]: node.tag.node,
          name: node.tag.name
        },
        component: node.component ? { [TS_NODE]: node.component.node, name: node.component.name } : void 0,
        attrs: buildAttrsMeta(checker, node.attrs),
        cssparts: buildCSSPartsMeta(doctags),
        slots: buildSlotsMeta(doctags)
      };
    },
    async buildReactComponentMeta(node) {
      const props = [], callbacks = [];
      if (node.types.props) {
        for (const prop of node.types.props.getProperties()) {
          if (isThirdPartyType(prop))
            continue;
          const signature = prop.declarations?.[0];
          if (!signature)
            continue;
          if (isReactProp(prop.name)) {
            if (ts.isPropertySignature(signature)) {
              const meta = buildPropMeta(checker, prop.name, signature, {
                type: checker.getTypeOfSymbol(prop)
              });
              if (meta)
                props.push(meta);
            }
          } else if (isReactCallback(prop.name)) {
            const callback = buildReactCallback(checker, signature);
            if (callback)
              callbacks.push(callback);
          }
        }
      }
      return {
        [TS_NODE]: node.root,
        type: "react",
        file: buildFileMeta(node.root),
        namespace: node.namespace,
        exports: node.exports,
        name: node.name,
        displayName: node.displayName,
        docs: getDocs(checker, node.identifier),
        doctags: getDocTags(node.statement ?? node.root),
        instance: node.instance,
        attributes: node.attributes,
        props: props?.length ? props : void 0,
        propsType: node.types.props ? serializeType(checker, node.types.props) : void 0,
        callbacks: callbacks?.length ? callbacks : void 0,
        ref: node.types.ref ? { type: buildTypeMeta(checker, node.types.ref) } : void 0
      };
    }
  };
}
const ignoredReactProps = /* @__PURE__ */ new Set(["style", "part", "ref"]);
function isReactProp(name) {
  return !isReactCallback(name) && !ignoredReactProps.has(name);
}
function isReactCallback(name) {
  return name.startsWith("on");
}
function isReactCallbackNode(node) {
  return ts.isMethodSignature(node) || ts.isPropertySignature(node) && !!node.type && ts.isFunctionTypeNode(node.type);
}
const cwd = process.cwd();
function isThirdPartyType(prop) {
  const parent = prop.declarations?.[0].parent, file = parent?.getSourceFile().fileName;
  return file && !file.startsWith(cwd);
}
function buildReactCallback(checker, node) {
  if (!isReactCallbackNode(node))
    return;
  let identifier = node.name, doctags = getDocTags(node), { internal, deprecated } = resolvePropTags(doctags), parameters;
  if (ts.isMethodSignature(node)) {
    parameters = node.parameters;
  } else if (ts.isPropertySignature(node) && node.type && ts.isFunctionTypeNode(node.type)) {
    parameters = node.type.parameters;
  }
  return {
    [TS_NODE]: node,
    name: identifier.escapedText,
    docs: getDocs(checker, identifier),
    doctags,
    type: buildTypeMeta(checker, checker.getTypeAtLocation(node)),
    parameters: parameters?.filter((param) => ts.isIdentifier(param.name) && param.type).map((param) => ({
      [TS_NODE]: param,
      name: param.name.escapedText,
      type: buildTypeMeta(checker, checker.getTypeAtLocation(param))
    })),
    internal,
    deprecated
  };
}

function getStaticProp(node, name) {
  return node.members.find(
    (member) => ts.isPropertyDeclaration(member) && member.modifiers && member.modifiers.some((modifier) => modifier.kind === ts.SyntaxKind.StaticKeyword) && ts.isIdentifier(member.name) && member.name.escapedText === name
  ) || null;
}

function discoverComponents(checker, sourceFile) {
  const discovered = [];
  ts.forEachChild(sourceFile, (node) => {
    if (!ts.isClassDeclaration(node) || !node.name || !node.heritageClauses)
      return;
    const heritage = getHeritage(checker, node), baseComponent = heritage.classes.get("Component");
    if (!baseComponent || !baseComponent.getSourceFile().fileName.includes("maverick"))
      return;
    const types = {
      root: checker.getTypeAtLocation(node)
    };
    const instanceSymbol = checker.getPropertyOfType(types.root, "$$"), instanceType = instanceSymbol && checker.getTypeOfSymbol(instanceSymbol);
    if (instanceType && instanceType.resolvedTypeArguments) {
      let i = 0;
      for (const arg of ["props", "state", "events", "cssvars"]) {
        types[arg] = node.typeParameters && node.typeParameters[i]?.default ? checker.getTypeAtLocation(node.typeParameters[i].default) : instanceType.resolvedTypeArguments[i];
        i++;
      }
    }
    let props;
    for (const [name, node2] of heritage.classes) {
      if (name === "Component")
        break;
      props = getStaticProp(node2, "props");
      if (props)
        break;
    }
    let state;
    for (const [name, node2] of heritage.classes) {
      if (name === "Component")
        break;
      state = getStaticProp(node2, "state");
      if (state)
        break;
    }
    discovered.push({
      name: node.name.escapedText,
      root: node,
      props,
      state,
      types
    });
  });
  return discovered;
}

function discoverCustomElements(checker, sourceFile) {
  const discovered = [];
  ts.forEachChild(sourceFile, (node) => {
    if (!ts.isClassDeclaration(node) || !node.name || !node.heritageClauses)
      return;
    const heritage = getHeritage(checker, node), hostMixin = heritage.mixins.get("Host"), hostMixinDeclaration = hostMixin && ts.isIdentifier(hostMixin.expression) && getDeclaration(checker, hostMixin.expression);
    if (!heritage.classes.has("HTMLElement") && (!hostMixinDeclaration || !hostMixinDeclaration.getSourceFile().fileName.includes("maverick"))) {
      return;
    }
    if (hostMixin && !ts.isIdentifier(hostMixin.arguments[1]))
      return;
    const component = hostMixin && getDeclaration(checker, hostMixin.arguments[1]);
    if (component && !ts.isClassDeclaration(component)) {
      reportDiagnosticByNode("expected component", hostMixin.arguments[1], LogLevel.Warn);
      return;
    }
    const tagNameProp = getStaticProp(node, "tagName");
    if (!tagNameProp) {
      reportDiagnosticByNode("missing static `tagName`", node, LogLevel.Warn);
      return;
    }
    if (!tagNameProp.initializer || !ts.isStringLiteral(tagNameProp.initializer)) {
      reportDiagnosticByNode("`tagName` must be a string literal", tagNameProp, LogLevel.Warn);
      return;
    }
    let attrs = getStaticProp(node, "attrs");
    if (attrs && (!attrs.initializer || !ts.isObjectLiteralExpression(attrs.initializer))) {
      reportDiagnosticByNode("`attrs` must be a object literal", attrs, LogLevel.Warn);
      attrs = void 0;
    }
    discovered.push({
      name: node.name.escapedText,
      root: node,
      tag: { node: tagNameProp, name: tagNameProp.initializer.text },
      component: component ? { node: component, name: component.name?.text || "" } : void 0,
      attrs
    });
  });
  return discovered;
}

const componentNameRE = /^[A-Z]/;
function discoverReactComponents(checker, sourceFile) {
  const discovered = [];
  ts.forEachChild(sourceFile, (node) => {
    if (ts.isExpressionStatement(node) && ts.isBinaryExpression(node.expression) && ts.isPropertyAccessExpression(node.expression.left) && node.expression.left.name.escapedText === "displayName" && ts.isStringLiteral(node.expression.right)) {
      const id = node.expression.left.expression;
      if (ts.isIdentifier(id)) {
        const name2 = id.escapedText, component2 = discovered.find((node2) => node2.name === name2);
        if (component2) {
          component2.displayName = node.expression.right.text + "";
        }
      }
    }
    if (ts.isExportDeclaration(node) && !node.isTypeOnly && node.exportClause && ts.isNamedExports(node.exportClause) && node.exportClause.elements.length > 1) {
      const file = node.getSourceFile().fileName, root2 = kebabToPascalCase(basename$1(file, extname$1(file)));
      for (const specifier of node.exportClause.elements) {
        const name2 = specifier.name.escapedText, component2 = discovered.find((node2) => node2.name === name2);
        if (component2) {
          component2.namespace = root2;
        }
      }
    }
    if (ts.isExportDeclaration(node) && !node.isTypeOnly && node.moduleSpecifier && ts.isStringLiteral(node.moduleSpecifier) && node.moduleSpecifier.text.startsWith(".")) {
      const filePath = node.getSourceFile().fileName, moduleFilePath = resolve$1(dirname$1(filePath), node.moduleSpecifier.text), component2 = discovered.find((c) => c.file === filePath);
      if (!component2)
        return;
      component2.exports ??= [];
      let currentExport = component2.exports.find((f) => f.file === moduleFilePath);
      if (!node.exportClause) {
        if (!currentExport)
          component2.exports.push({ file: moduleFilePath });
      } else if (ts.isNamedExports(node.exportClause)) {
        if (!currentExport) {
          currentExport = { file: moduleFilePath, alias: {} };
          component2.exports.push(currentExport);
        }
        for (const el of node.exportClause.elements) {
          const name2 = el.name.escapedText, propName = el.propertyName?.escapedText ?? name2;
          currentExport.alias[propName] = name2;
        }
      }
    }
    if (!ts.isFunctionDeclaration(node) && !ts.isVariableStatement(node)) {
      return;
    }
    const root = ts.isVariableStatement(node) ? node.declarationList.declarations[0] : node;
    if (!root || !root.name || !ts.isIdentifier(root.name))
      return;
    const name = root.name.escapedText;
    if (!componentNameRE.test(name))
      return;
    let component, refType = void 0, propsType = void 0;
    if (ts.isVariableDeclaration(root)) {
      if (!root.initializer) {
        return;
      } else if (ts.isFunctionDeclaration(root.initializer) || ts.isArrowFunction(root.initializer)) {
        component = root.initializer;
      } else if (ts.isCallExpression(root.initializer)) {
        let args = root.initializer.arguments, expression = root.initializer.expression, typeArgs = root.initializer.typeArguments;
        if (ts.isPropertyAccessExpression(expression))
          expression = expression.name;
        if (!expression || !ts.isIdentifier(expression))
          return;
        if (expression.escapedText !== "forwardRef") {
          let node2 = getDeclaration(checker, expression);
          if (node2 && ts.isVariableDeclaration(node2))
            node2 = node2.initializer;
          if (node2 && (ts.isFunctionDeclaration(node2) || ts.isArrowFunction(node2))) {
            const returns = getReturnExpression(node2);
            if (!returns)
              return;
            if (returns && ts.isCallExpression(returns)) {
              let name2 = returns.expression;
              if (ts.isPropertyAccessExpression(name2))
                name2 = name2.name;
              if (ts.isIdentifier(name2) && name2.escapedText === "forwardRef") {
                args = returns.arguments;
                typeArgs = returns.typeArguments;
              }
            }
          }
        }
        if (args[0] && (ts.isFunctionDeclaration(args[0]) || ts.isArrowFunction(args[0]))) {
          component = args[0];
          if (typeArgs?.[0])
            refType = checker.getTypeAtLocation(typeArgs[0]);
          if (typeArgs?.[1])
            propsType = checker.getTypeAtLocation(typeArgs[1]);
        }
      }
    } else {
      component = root;
    }
    if (!component)
      return;
    let propsParam = component.parameters[0], instance, attributes;
    if (!propsType) {
      propsType = propsParam ? checker.getTypeAtLocation(propsParam) : void 0;
    }
    let props = propsType?.symbol?.declarations?.[0];
    if (props) {
      ({ instance, attributes } = findElementTypeArgs(checker, props));
    }
    if (!attributes && propsType) {
      const reactModule = /node_modules\/(@types\/)?react/;
      for (const prop of propsType.getProperties()) {
        const declaration = prop.declarations?.[0], file = declaration?.getSourceFile().fileName;
        if (declaration && ts.isInterfaceDeclaration(declaration.parent) && reactModule.test(file)) {
          const name2 = declaration.parent.name.escapedText;
          if (name2.includes("Attributes")) {
            attributes = name2;
            break;
          }
        }
      }
    }
    discovered.push({
      file: root.getSourceFile().fileName,
      name,
      root,
      statement: ts.isVariableStatement(node) ? node : void 0,
      component,
      identifier: root.name,
      instance,
      attributes,
      props,
      types: {
        root: checker.getTypeAtLocation(root),
        ref: refType,
        props: propsType
      }
    });
  });
  return discovered;
}
function findElementTypeArgs(checker, props) {
  let instance, attributes;
  walkTypeHeritage(checker, props, {
    heritageClause(node) {
      let id = node.types[0]?.expression, typeArgs = node.types, unwrapped = false;
      const firstTypeArg = typeArgs[0];
      if (firstTypeArg && ts.isExpressionWithTypeArguments(firstTypeArg) && ts.isIdentifier(firstTypeArg.expression) && /Omit|Pick/.test(firstTypeArg.expression.escapedText + "") && firstTypeArg.typeArguments) {
        const arg = firstTypeArg.typeArguments[0];
        if (arg && ts.isTypeReferenceNode(arg) && ts.isIdentifier(arg.typeName)) {
          id = arg.typeName;
          typeArgs = arg.typeArguments;
          unwrapped = true;
        }
      }
      if (ts.isPropertyAccessExpression(id)) {
        id = id.name;
      }
      if (ts.isIdentifier(id)) {
        if (id.escapedText.includes("Attributes")) {
          const declaration = getDeclaration(checker, id), file = declaration?.getSourceFile().fileName;
          if (file && /node_modules\/(@types\/)?react/.test(file)) {
            const attrsName = typeArgs?.[0].getFullText().trim().replace("React.", "");
            if (attrsName) {
              attributes = attrsName;
              return true;
            }
          }
        } else if (id.escapedText === "ReactElementProps") {
          if (!unwrapped && typeArgs?.[0]) {
            if (ts.isTypeReferenceNode(typeArgs[0]) || ts.isExpressionWithTypeArguments(typeArgs[0])) {
              typeArgs = typeArgs[0].typeArguments;
            }
          }
          const instanceTypeArg = typeArgs?.[0], elTypeArg = typeArgs?.[1];
          if (instanceTypeArg) {
            instance = serializeType(checker, checker.getTypeAtLocation(instanceTypeArg)).replace(
              /<(.*?)>/,
              ""
            );
          }
          if (elTypeArg && ts.isTypeReferenceNode(elTypeArg)) {
            const id2 = elTypeArg.typeName;
            if (ts.isIdentifier(id2)) {
              attributes = `HTMLAttributes<${id2.escapedText}>`;
            }
          } else {
            attributes = `HTMLAttributes`;
          }
          return true;
        }
      }
    }
  });
  return { instance, attributes };
}

function createDiscoverPlugin() {
  let checker;
  return {
    name: "maverick/discover",
    async init(program) {
      checker = program.getTypeChecker();
    },
    async discoverComponents(sourceFile) {
      return discoverComponents(checker, sourceFile);
    },
    async discoverCustomElements(sourceFile) {
      return discoverCustomElements(checker, sourceFile);
    },
    async discoverReactComponents(sourceFile) {
      return discoverReactComponents(checker, sourceFile);
    }
  };
}

async function runPluginsInit(program, plugins) {
  for (const plugin of plugins) {
    if (isUndefined(plugin.init))
      continue;
    const startTime = process.hrtime();
    await plugin.init(program);
    logTime(`${formatPluginName(plugin.name)} \`init\``, startTime, LogLevel.Verbose);
  }
}
let prevHash;
async function runPlugins(program, plugins, paths, framework = "default", watching = false) {
  const validFilePaths = new Set(paths);
  const sourceFiles = program.getSourceFiles().filter((sf) => validFilePaths.has(resolvePath(sf.fileName))).sort((sfA, sfB) => sfA.fileName > sfB.fileName ? 1 : -1);
  if (watching) {
    const hashSum = createHash("sha256");
    for (const file of sourceFiles)
      hashSum.update(file.text);
    const newHash = hashSum.digest("hex");
    if (prevHash !== newHash) {
      prevHash = newHash;
    } else {
      return;
    }
  }
  await runPluginsInit(program, plugins);
  const components = [], customElements = [], reactComponents = [], transformSourceFiles = /* @__PURE__ */ new Map();
  for (const sourceFile of sourceFiles) {
    const nodes = await runPluginsDiscover(plugins, sourceFile, framework);
    if (framework === "default") {
      for (const node of nodes.components) {
        const component = await runPluginsBuildComponent(plugins, node);
        if (!component)
          continue;
        transformSourceFiles.set(component, sourceFile);
        components.push(component);
      }
      for (const node of nodes.customElements) {
        const element = await runPluginsBuildCustomElement(plugins, node);
        if (!element)
          continue;
        transformSourceFiles.set(element, sourceFile);
        customElements.push(element);
      }
    } else if (framework === "react") {
      for (const node of nodes.reactComponents) {
        const component = await runPluginsBuildReactComponent(plugins, node);
        if (!component)
          continue;
        transformSourceFiles.set(component, sourceFile);
        reactComponents.push(component);
      }
    }
  }
  await runPluginsTransform(
    plugins,
    { components, customElements, reactComponents },
    transformSourceFiles
  );
  await runPluginsDestroy(plugins);
  return { sourceFiles };
}
async function runPluginsDiscover(plugins, sourceFile, framework) {
  for (const plugin of plugins) {
    if (isUndefined(plugin.discoverComponents) && isUndefined(plugin.discoverCustomElements) && isUndefined(plugin.discoverReactComponents)) {
      continue;
    }
    const startTime = process.hrtime(), components = framework === "default" ? await plugin.discoverComponents?.(sourceFile) : void 0, customElements = framework === "default" ? await plugin.discoverCustomElements?.(sourceFile) : void 0, reactComponents = framework === "react" ? await plugin.discoverReactComponents?.(sourceFile) : void 0;
    logTime(`${formatPluginName(plugin.name)} \`discover\``, startTime, LogLevel.Verbose);
    if (components) {
      log(
        `${formatPluginName(plugin.name)} discovered components in ${$.blue(
          sourceFile.fileName
        )}`,
        LogLevel.Verbose
      );
    }
    if (customElements) {
      log(
        `${formatPluginName(plugin.name)} discovered elements in ${$.blue(
          sourceFile.fileName
        )}`,
        LogLevel.Verbose
      );
    }
    if (reactComponents) {
      log(
        `${formatPluginName(plugin.name)} discovered react components in ${$.blue(
          sourceFile.fileName
        )}`,
        LogLevel.Verbose
      );
    }
    if (components || customElements || reactComponents) {
      return {
        components: components || [],
        customElements: customElements || [],
        reactComponents: reactComponents || []
      };
    }
  }
  return {
    components: [],
    customElements: [],
    reactComponents: []
  };
}
async function runPluginsBuildComponent(plugins, node) {
  for (const plugin of plugins) {
    if (isUndefined(plugin.buildComponentMeta))
      continue;
    const startTime = process.hrtime(), component = node && await plugin.buildComponentMeta(node);
    logTime(`${formatPluginName(plugin.name)} \`build\``, startTime, LogLevel.Verbose);
    if (component) {
      log(
        `${formatPluginName(plugin.name)} built component meta for ${$.blue(component.name)}`,
        LogLevel.Verbose
      );
    }
    if (component) {
      return component;
    }
  }
  return null;
}
async function runPluginsBuildCustomElement(plugins, node) {
  for (const plugin of plugins) {
    if (isUndefined(plugin.buildCustomElementMeta))
      continue;
    const startTime = process.hrtime(), element = node && await plugin.buildCustomElementMeta(node);
    logTime(`${formatPluginName(plugin.name)} \`build\``, startTime, LogLevel.Verbose);
    if (element) {
      log(
        `${formatPluginName(plugin.name)} built element meta for ${$.blue(element.tag.name)}`,
        LogLevel.Verbose
      );
    }
    if (element) {
      return element;
    }
  }
  return null;
}
async function runPluginsBuildReactComponent(plugins, node) {
  for (const plugin of plugins) {
    if (isUndefined(plugin.buildReactComponentMeta))
      continue;
    const startTime = process.hrtime(), component = node && await plugin.buildReactComponentMeta(node);
    logTime(`${formatPluginName(plugin.name)} \`build\``, startTime, LogLevel.Verbose);
    if (component) {
      log(
        `${formatPluginName(plugin.name)} built react component meta for ${$.blue(
          component.name
        )}`,
        LogLevel.Verbose
      );
    }
    if (component) {
      return component;
    }
  }
  return null;
}
async function runPluginsTransform(plugins, data, sourceFiles) {
  for (const plugin of plugins) {
    if (isUndefined(plugin.transform))
      continue;
    const startTime = process.hrtime();
    await plugin.transform(data, sourceFiles);
    logTime(`${formatPluginName(plugin.name)} \`transform\``, startTime, LogLevel.Verbose);
  }
}
async function runPluginsDestroy(plugins) {
  for (const plugin of plugins) {
    if (isUndefined(plugin.destroy))
      continue;
    const startTime = process.hrtime();
    await plugin.destroy();
    logTime(`${formatPluginName(plugin.name)} \`destroy\``, startTime, LogLevel.Verbose);
  }
}

const IGNORE_GLOBS = ["**/node_modules/**", "**/web_modules/**"];
const DEFAULT_DIR_GLOB = "**/*.{js,jsx,ts,tsx}";
const DEFAULT_GLOBS = [DEFAULT_DIR_GLOB];
async function parseGlobs(globs) {
  if (globs.length === 0) {
    globs = DEFAULT_GLOBS;
  }
  const filePaths = await expandGlobs(globs);
  return filePaths.map((filePath) => normalize$1(filePath));
}
async function expandGlobs(globs) {
  globs = Array.isArray(globs) ? globs : [globs];
  const { existsSync, lstatSync } = await import('node:fs');
  const filePaths = await Promise.all(
    globs.map((g) => {
      try {
        const dirExists = existsSync(g) && lstatSync(g).isDirectory();
        if (dirExists) {
          return globbySync([fastGlobNormalize(`${g}/${DEFAULT_DIR_GLOB}`)], {
            ignore: IGNORE_GLOBS,
            absolute: true,
            followSymbolicLinks: false
          });
        }
      } catch (e) {
      }
      return globbySync([fastGlobNormalize(g)], {
        ignore: IGNORE_GLOBS,
        absolute: true,
        followSymbolicLinks: false
      });
    })
  );
  return filePaths.flat();
}
function fastGlobNormalize(glob) {
  return glob.replace(/\\/g, "/");
}

const defaultOptions = {
  noEmitOnError: false,
  allowJs: true,
  experimentalDecorators: true,
  target: ts.ScriptTarget.ES2020,
  downlevelIteration: true,
  module: ts.ModuleKind.ESNext,
  strictNullChecks: true,
  moduleResolution: ts.ModuleResolutionKind.NodeJs,
  esModuleInterop: true,
  noEmit: true,
  pretty: true,
  allowSyntheticDefaultImports: true,
  allowUnreachableCode: true,
  allowUnusedLabels: true,
  skipDefaultLibCheck: true
};
function compileOnce(filePaths, options = defaultOptions) {
  return ts.createProgram(filePaths, options);
}
({
  [ts.DiagnosticCategory.Warning]: LogLevel.Warn,
  [ts.DiagnosticCategory.Error]: LogLevel.Error,
  [ts.DiagnosticCategory.Message]: LogLevel.Info,
  [ts.DiagnosticCategory.Suggestion]: LogLevel.Info
});
function compileAndWatch(configFileName, onProgramCreate) {
  const host = ts.createWatchCompilerHost(
    configFileName,
    {},
    ts.sys,
    ts.createSemanticDiagnosticsBuilderProgram,
    // Ignore diagnostic errors.
    () => {
    },
    () => {
    }
    // reportDiagnostic,
    // reportWatchStatusChanged,
  );
  const afterProgramCreate = host.afterProgramCreate;
  host.afterProgramCreate = async (builderProgram) => {
    const program = builderProgram.getProgram();
    afterProgramCreate(builderProgram);
    await onProgramCreate(program);
  };
  return ts.createWatchProgram(host);
}
async function transpileModuleOnce(filePath) {
  const { existsSync, mkdirSync, readFileSync, writeFileSync } = await import('node:fs');
  const sourceText = readFileSync(filePath, "utf8").toString();
  const transpiledResult = ts.transpileModule(sourceText, {
    compilerOptions: defaultOptions
  });
  const tmpDir = resolve$1(process.cwd(), "node_modules/.temp");
  if (!existsSync(tmpDir)) {
    mkdirSync(tmpDir);
  }
  const transpiledFilePath = resolve$1(tmpDir, "config.mjs");
  writeFileSync(transpiledFilePath, transpiledResult.outputText);
  try {
    return (await import(transpiledFilePath + `?t=${Date.now()}`))?.default ?? [];
  } catch (e) {
    return {};
  }
}

async function normalizeConfig(config) {
  const cwd = isUndefined(config.cwd) ? process.cwd() : config.cwd;
  return resolveConfigPaths(cwd, config);
}
async function runAnalyzeCommand(analyzeConfig) {
  clearTerminal();
  const config = await normalizeConfig(analyzeConfig);
  const glob = config.glob ?? [];
  log(config, LogLevel.Verbose);
  let plugins = [];
  const { existsSync } = await import('node:fs');
  if (!existsSync(config.configFile)) {
    log(
      `no configuration file could be found at ${$.cyan(config.configFile)}`,
      LogLevel.Verbose
    );
  } else {
    plugins = await transpileModuleOnce(config.configFile);
  }
  if (!isArray(plugins)) {
    log(
      `configuration file must default export an array of plugins, found ${$.red(
        typeof plugins
      )}`,
      LogLevel.Error
    );
    return;
  }
  plugins.push(createDiscoverPlugin(), createBuildPlugin());
  if (config.watch) {
    log("watching files for changes...");
    compileAndWatch(config.project ?? "tsconfig.json", async (program) => {
      const filePaths = await parseGlobs(glob);
      await run(program, plugins, filePaths, config.framework, true);
    });
  } else {
    const startCompileTime = process.hrtime();
    const filePaths = await parseGlobs(glob);
    const program = compileOnce(filePaths, {
      project: config.project ?? "tsconfig.json"
    });
    logTime(`compiled program`, startCompileTime);
    await run(program, plugins, filePaths, config.framework);
  }
}
async function run(program, plugins, filePaths, framework = void 0, watching = false) {
  const startAnalyzeTime = process.hrtime();
  const result = await runPlugins(program, plugins, filePaths, framework, watching);
  if (result) {
    const { sourceFiles } = result;
    const noOfFiles = sourceFiles.length;
    const noOfFilesText = $.green(`${noOfFiles} ${noOfFiles === 1 ? "file" : "files"}`);
    logTime(`analyzed ${noOfFilesText}`, startAnalyzeTime);
  }
}

function cli() {
  yargs(hideBin(process.argv)).usage("Usage: $0 <command> [glob..] [options]").command(
    ["analyze [glob..]", "$0 [glob..]"],
    "Analyzes component metadata.",
    () => {
    },
    async (config) => {
      setGlobalLogLevel(mapLogLevelStringToNumber(config.logLevel));
      try {
        await runAnalyzeCommand(config);
      } catch (e) {
        if (e instanceof Error) {
          logStackTrace(e.message, e.stack);
        } else {
          throw e;
        }
      }
    }
  ).example("$ $0", "").option("cwd", {
    string: true,
    describe: "The base path to use when emitting files (useful when working inside a monorepo).",
    default: process.cwd()
  }).option("logLevel", {
    describe: "Select logging level.",
    nArgs: 1,
    choices: ["silent", "error", "warn", "info", "verbose"],
    default: "info"
  }).option("configFile", {
    alias: "c",
    string: true,
    describe: "The path to your configuration file.",
    default: "./analyze.config.ts"
  }).option("framework", {
    describe: "Select the JS framework that is being analyzed.",
    nArgs: 1,
    choices: ["default", "react"],
    default: "default"
  }).option("watch", {
    alias: "w",
    boolean: true,
    describe: "Watch input files for changes.",
    default: false
  }).option("project", {
    alias: "p",
    string: true,
    describe: "Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json' file.",
    default: null
  }).alias("v", "version").help("h").wrap(110).strict().alias("h", "help").argv;
}

export { cli };
