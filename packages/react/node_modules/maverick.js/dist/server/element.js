import { isArray, isString, scoped } from './chunks/maverick-gr-NKUum.js';
import { PROPS, METHODS, createComponent } from './chunks/maverick-Dgy9432B.js';
import { runAll } from './chunks/maverick-6LqLvq_5.js';
import { camelToKebabCase } from './chunks/maverick-jhjCtVsR.js';
import { ATTRS, SETUP_STATE, SETUP_CALLBACKS, SETUP } from './chunks/maverick-0bhStPuN.js';

const STRING = (v) => (v === null ? '' : v + '');
const NULLABLE_STRING = (v) =>
  v === null ? null : v + '';
const NUMBER = (v) => (v === null ? 0 : Number(v));
const NULLABLE_NUMBER = (v) =>
  v === null ? null : Number(v);
const BOOLEAN = (v) => v !== null;
const FUNCTION = () => null;
const ARRAY = (v) => (v === null ? [] : JSON.parse(v));
const OBJECT = (v) => (v === null ? {} : JSON.parse(v));

function inferAttributeConverter(value) {
  if (value === null) return NULLABLE_STRING;
  switch (typeof value) {
    case 'undefined':
      return STRING;
    case 'string':
      return STRING;
    case 'boolean':
      return BOOLEAN;
    case 'number':
      return NUMBER;
    case 'function':
      return FUNCTION;
    case 'object':
      return isArray(value) ? ARRAY : OBJECT;
    default:
      return STRING;
  }
}

var SetupState; (function (SetupState) {
  const Idle = 0; SetupState[SetupState["Idle"] = Idle] = "Idle";
  const Pending = 1; SetupState[SetupState["Pending"] = Pending] = "Pending";
  const Ready = 2; SetupState[SetupState["Ready"] = Ready] = "Ready";
})(SetupState || (SetupState = {}));

function Host(
  Super,
  Component,
) {
  // @ts-expect-error
  class MaverickElement extends Super  {
    static attrs;

     static [ATTRS]


 = null;

    static get observedAttributes() {
      if (!this[ATTRS] && Component.props) {
        const map = new Map();

        for (const propName of Object.keys(Component.props)) {
          let attr = this.attrs?.[propName],
            attrName = isString(attr) ? attr : !attr ? attr : attr?.attr;

          if (attrName === false) continue;
          if (!attrName) attrName = camelToKebabCase(propName);

          map.set(attrName, {
            prop: propName,
            converter:
              (attr && !isString(attr) && attr?.converter) ||
              inferAttributeConverter(Component.props[propName]),
          });
        }

        this[ATTRS] = map;
      }

      return this[ATTRS] ? Array.from(this[ATTRS].keys()) : [];
    }

     $;
    [SETUP_STATE] = SetupState.Idle;
    [SETUP_CALLBACKS] = null;

    keepAlive = false;
    forwardKeepAlive = true;

    get scope() {
      return this.$.$$.scope;
    }

    get attachScope() {
      return this.$.$$.attachScope;
    }

    get connectScope() {
      return this.$.$$.connectScope;
    }

    get $props() {
      return this.$.$$.props ;
    }

    get $state() {
      return this.$.$$.$state ;
    }

    get state() {
      return this.$.state ;
    }

    constructor(...args) {
      super(...args);

      this.$ = scoped(() => createComponent(Component), null);
      this.$.$$.addHooks(this );

      // Properties might be assigned before element is registered. We need to assign them
      // to the internal prop signals and delete from proto chain.
      if (Component.props) {
        const props = this.$props,
          descriptors = Object.getOwnPropertyDescriptors(this);
        for (const prop of Object.keys(descriptors)) {
          if (prop in Component.props) {
            props[prop].set(this[prop]);
            delete this[prop];
          }
        }
      }
    }

    attributeChangedCallback(name, _, newValue) {
      const Ctor = this.constructor ;

      if (!Ctor[ATTRS]) {
        // @ts-expect-error
        super.attributeChangedCallback?.(name, _, newValue);
        return;
      }

      const def = Ctor[ATTRS].get(name);
      if (def) this[def.prop] = (def.converter )(newValue);
    }

    connectedCallback() {
      const instance = this.$?.$$;
      if (!instance || instance.destroyed) return;

      if (this[SETUP_STATE] !== SetupState.Ready) {
        setup.call(this);
        return;
      }

      // Could be called once element is no longer connected.
      if (!this.isConnected) return;

      if (this.hasAttribute('keep-alive')) {
        this.keepAlive = true;
      }

      instance.connect();

      if (isArray(this[SETUP_CALLBACKS])) runAll(this[SETUP_CALLBACKS], this);
      this[SETUP_CALLBACKS] = null;

      // @ts-expect-error
      const callback = super.connectedCallback;
      if (callback) scoped(() => callback.call(this), this.connectScope);

      return;
    }

    disconnectedCallback() {
      const instance = this.$?.$$;
      if (!instance || instance.destroyed) return;

      instance.disconnect();

      // @ts-expect-error
      const callback = super.disconnectedCallback;
      if (callback) callback.call(this);

      if (!this.keepAlive && !this.hasAttribute('keep-alive')) {
        setTimeout(() => {
          requestAnimationFrame(() => {
            if (!this.isConnected) instance.destroy();
          });
        }, 0);
      }
    }

    [SETUP]() {
      const instance = this.$.$$,
        Ctor = this.constructor ;

      if (instance.destroyed) return;

      const attrs = Ctor[ATTRS];
      if (attrs) {
        for (const attr of this.attributes) {
          let def = attrs.get(attr.name);
          if (def && def.converter) {
            instance.props[def.prop].set(def.converter(this.getAttribute(attr.name)));
          }
        }
      }

      instance.setup();
      instance.attach(this);
      this[SETUP_STATE] = SetupState.Ready;

      this.connectedCallback();
    }

    // @ts-expect-error
    subscribe(callback) {
      return this.$.subscribe(callback);
    }

    destroy() {
      this.disconnectedCallback();
      this.$.destroy();
    }
  }

  extendProto(MaverickElement, Component);
  return MaverickElement ;
}


























































































































function extendProto(Element, Component) {
  const ElementProto = Element.prototype,
    ComponentProto = Component.prototype;

  if (Component.props) {
    for (const prop of Object.keys(Component.props)) {
      Object.defineProperty(ElementProto, prop, {
        enumerable: true,
        configurable: true,
        get() {
          return this.$props[prop]();
        },
        set( value) {
          this.$props[prop].set(value);
        },
      });
    }
  }

  if (ComponentProto[PROPS]) {
    for (const name of ComponentProto[PROPS]) {
      Object.defineProperty(ElementProto, name, {
        enumerable: true,
        configurable: true,
        get() {
          return this.$[name];
        },
        set( value) {
          this.$[name] = value;
        },
      });
    }
  }

  if (ComponentProto[METHODS]) {
    for (const name of ComponentProto[METHODS]) {
      ElementProto[name] = function ( ...args) {
        return this.$[name](...args);
      };
    }
  }
}

function setup() {
  if (this[SETUP_STATE] !== SetupState.Idle) return;
  this[SETUP_STATE] = SetupState.Pending;

  const parent = findParent(this),
    isParentRegistered = parent && window.customElements.get(parent.localName),
    isParentSetup = parent && parent[SETUP_STATE] === SetupState.Ready;

  if (parent && (!isParentRegistered || !isParentSetup)) {
    waitForParent.call(this, parent);
    return;
  }

  attach.call(this, parent);
}

async function waitForParent( parent) {
  await window.customElements.whenDefined(parent.localName);

  if (parent[SETUP_STATE] !== SetupState.Ready) {
    await new Promise((res) => (parent[SETUP_CALLBACKS] ??= []).push(res));
  }

  attach.call(this, parent);
}

function attach( parent) {
  // Skip setting up if we disconnected while waiting for parent to connect.
  if (!this.isConnected) return;

  if (parent) {
    if (parent.keepAlive && parent.forwardKeepAlive) {
      this.keepAlive = true;
      this.setAttribute('keep-alive', '');
    }

    const scope = this.$.$$.scope;
    if (scope) parent.$.$$.attachScope.append(scope);
  }

  this[SETUP]();
}

function findParent(host) {
  let node = host.parentNode,
    prefix = host.localName.split('-', 1)[0] + '-';

  while (node) {
    if (node.nodeType === 1 && (node ).localName.startsWith(prefix)) {
      return node ;
    }

    node = node.parentNode;
  }

  return null;
}

function defineCustomElement(element, throws = false) {
  return;
}

export { ARRAY, BOOLEAN, FUNCTION, Host, NULLABLE_NUMBER, NULLABLE_STRING, NUMBER, OBJECT, STRING, defineCustomElement, inferAttributeConverter };
