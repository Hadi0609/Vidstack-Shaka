import * as React from 'react';
import { provideContext, createComponent, effect, signal } from './chunks/maverick-Dgy9432B.js';
import { getContext, createScope, scoped, noop, isFunction, isArray } from './chunks/maverick-gr-NKUum.js';
import { SETUP } from './chunks/maverick-0bhStPuN.js';
import { kebabToCamelCase } from './chunks/maverick-jhjCtVsR.js';
import { effect as effect$1 } from './chunks/maverick-KzXDbR3K.js';

const ReactScopeContext = React.createContext({ current: null });
ReactScopeContext.displayName = 'Scope';

function WithScope(scope, ...children) {
  return React.createElement(ReactScopeContext.Provider, { value: scope }, ...children);
}

function useReactScope() {
  return React.useContext(ReactScopeContext).current;
}

function useReactContext(context) {
  const scope = useReactScope();
  return React.useMemo(() => getContext(context.id, scope), [scope]);
}

function createReactScopeProvider() {
  return ScopeProvider;
}

function createReactContextProvider(
  context,
  provide,
) {
  return class ContextProvider extends ScopeProvider {
    static  #context = context;
    static  #provide = provide;
  };
}

class ScopeProvider extends React.Component {
  static  contextType = ReactScopeContext;
  ;

  static #context;
  static #provide;

  #scope;

  constructor(props, context) {
    super(props);

    this.#scope = {
      current: createScope(),
    };

    if (context) context.append(this.#scope.current);

    const Ctor = this.constructor ;
    if (Ctor.#context) provideContext(Ctor.#context, Ctor.#provide?.(), this.#scope.current);
  }

   render() {
    return WithScope(this.#scope, this.props?.children);
  }
}

function setRef(ref, value) {
  if (typeof ref === 'function') {
    (ref )(value);
  } else if (ref) {
    (ref ).current = value;
  }
}



function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}

function escape(value, isAttr = false) {
  const type = typeof value;

  if (type !== 'string') {
    if (!isAttr && type === 'function') return escape(value());
    if (isAttr && type === 'boolean') return value + '';
    return value;
  }

  const delimeter = isAttr ? '"' : '<',
    escapeDelimeter = isAttr ? '&quot;' : '&lt;';

  let iDelimeter = value.indexOf(delimeter),
    isAmpersand = value.indexOf('&');

  if (iDelimeter < 0 && isAmpersand < 0) return value;

  let left = 0,
    out = '';

  while (iDelimeter >= 0 && isAmpersand >= 0) {
    if (iDelimeter < isAmpersand) {
      if (left < iDelimeter) out += value.substring(left, iDelimeter);
      out += escapeDelimeter;
      left = iDelimeter + 1;
      iDelimeter = value.indexOf(delimeter, left);
    } else {
      if (left < isAmpersand) out += value.substring(left, isAmpersand);
      out += '&amp;';
      left = isAmpersand + 1;
      isAmpersand = value.indexOf('&', left);
    }
  }

  if (iDelimeter >= 0) {
    do {
      if (left < iDelimeter) out += value.substring(left, iDelimeter);
      out += escapeDelimeter;
      left = iDelimeter + 1;
      iDelimeter = value.indexOf(delimeter, left);
    } while (iDelimeter >= 0);
  } else
    while (isAmpersand >= 0) {
      if (left < isAmpersand) out += value.substring(left, isAmpersand);
      out += '&amp;';
      left = isAmpersand + 1;
      isAmpersand = value.indexOf('&', left);
    }

  return left < value.length ? out + value.substring(left) : out;
}

const classSplitRE = /\s+/;
function parseClassAttr(tokens, attrValue) {
  const classes = attrValue.trim().split(classSplitRE);
  for (const token of classes) tokens.add(token);
}

const styleSplitRE = /\s*:\s*/;
const stylesDelimeterRE = /\s*;\s*/;
function parseStyleAttr(tokens, attrValue) {
  const styles = attrValue.trim().split(stylesDelimeterRE);
  for (let i = 0; i < styles.length; i++) {
    if (styles[i] === '') continue;
    const [name, value] = styles[i].split(styleSplitRE);
    tokens.set(name, value);
  }
}

class MaverickServerElement {
  keepAlive = false;
  forwardKeepAlive = true;

   $;
   attributes = new ServerAttributes();
   style = new ServerStyle();
   classList = new ServerClassList();

  get $props() {
    return this.$.$$.props;
  }

  get $state() {
    return this.$.$$.$state;
  }

  get state() {
    return this.$.state;
  }

  constructor(component) {
    this.$ = component;
  }

  setup() {
    const instance = this.$.$$;
    scoped(() => {
      if (this.hasAttribute('class')) {
        parseClassAttr(this.classList.tokens, this.getAttribute('class'));
      }

      if (this.hasAttribute('style')) {
        parseStyleAttr(this.style.tokens, this.getAttribute('style'));
      }

      instance.setup();
      instance.attach(this);

      if (this.classList.length > 0) {
        this.setAttribute('class', this.classList.toString());
      }

      if (this.style.length > 0) {
        this.setAttribute('style', this.style.toString());
      }

      if (this.keepAlive) {
        this.setAttribute('keep-alive', '');
      }
    }, instance.scope);
  }

  getAttribute(name) {
    return this.attributes.getAttribute(name);
  }

  setAttribute(name, value) {
    this.attributes.setAttribute(name, value);
  }

  hasAttribute(name) {
    return this.attributes.hasAttribute(name);
  }

  removeAttribute(name) {
    return this.attributes.removeAttribute(name);
  }

  [SETUP]() {}
  addEventListener() {}
  removeEventListener() {}

  dispatchEvent() {
    return false;
  }

  subscribe() {
    return noop;
  }

  destroy() {
    this.$.destroy();
  }
}

class ServerAttributes {
  #tokens = new Map();
  get length() {
    return this.#tokens.size;
  }
  get tokens() {
    return this.#tokens;
  }
  getAttribute(name) {
    return this.#tokens.get(name) ?? null;
  }
  hasAttribute(name) {
    return this.#tokens.has(name);
  }
  setAttribute(name, value) {
    this.#tokens.set(name, value + '');
  }
  removeAttribute(name) {
    this.#tokens.delete(name);
  }
  toString() {
    if (this.#tokens.size === 0) return '';
    let result = '';
    for (const [name, value] of this.#tokens) {
      result += ` ${name}="${escape(value, true)}"`;
    }
    return result;
  }
}

class ServerStyle {
  #tokens = new Map();
  get length() {
    return this.#tokens.size;
  }
  get tokens() {
    return this.#tokens;
  }
  getPropertyValue(prop) {
    return this.#tokens.get(prop) ?? '';
  }
  setProperty(prop, value) {
    this.#tokens.set(prop, value ?? '');
  }
  removeProperty(prop) {
    const value = this.#tokens.get(prop);
    this.#tokens.delete(prop);
    return value ?? '';
  }
  toString() {
    if (this.#tokens.size === 0) return '';
    let result = '';
    for (const [name, value] of this.#tokens) {
      result += `${name}: ${value};`;
    }
    return result;
  }
}






















class ServerClassList {
  #tokens = new Set();
  get length() {
    return this.#tokens.size;
  }
  get tokens() {
    return this.#tokens;
  }
  add(...tokens) {
    for (const token of tokens) {
      this.#tokens.add(token);
    }
  }
  contains(token) {
    return this.#tokens.has(token);
  }
  remove(token) {
    this.#tokens.delete(token);
  }
  replace(token, newToken) {
    if (!this.#tokens.has(token)) return false;
    this.#tokens.delete(token);
    this.#tokens.add(newToken);
    return true;
  }
  toggle(token, force) {
    if (force !== true && (this.#tokens.has(token) || force === false)) {
      this.#tokens.delete(token);
      return false;
    } else {
      this.#tokens.add(token);
      return true;
    }
  }
  toString() {
    return Array.from(this.#tokens).join(' ');
  }
}

const attrsToProps = {
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  allowfullscreen: 'allowFullScreen',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  charset: 'charSet',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  colspan: 'colSpan',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controlslist: 'controlsList',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  datetime: 'dateTime',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  disablepictureinpicture: 'disablePictureInPicture',
  disableremoteplayback: 'disableRemotePlayback',
  enctype: 'encType',
  enterkeyhint: 'enterKeyHint',
  fetchpriority: 'fetchPriority',
  for: 'htmlFor',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  imagesizes: 'imageSizes',
  imagesrcset: 'imageSrcSet',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  maxlength: 'maxLength',
  mediagroup: 'mediaGroup',
  minlength: 'minLength',
  nomodule: 'noModule',
  novalidate: 'noValidate',
  playsinline: 'playsInline',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rowspan: 'rowSpan',
  spellcheck: 'spellCheck',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  tabindex: 'tabIndex',
  usemap: 'useMap',
};

function createServerComponent(
  Component,
  options,
) {
  function ServerComponent(props) {
    let scope = React.useContext(ReactScopeContext),
      component = createComponent(Component, {
        props,
        scope: scope.current,
      }),
      host = new MaverickServerElement(component),
      attrs = {},
      { style = {}, children, forwardRef, ...renderProps } = props;

    if (options.props.size) {
      for (const prop of Object.keys(renderProps)) {
        if (!options.props.has(prop)) attrs[prop] = renderProps[prop];
      }
    } else {
      attrs = renderProps;
    }

    host.setup();

    if (host.hasAttribute('style')) {
      for (const [name, value] of host.style.tokens) {
        style[name.startsWith('--') ? name : kebabToCamelCase(name)] = value;
      }

      host.removeAttribute('style');
    }

    for (const [attrName, attrValue] of host.attributes.tokens) {
      const propName = attrsToProps[attrName];
      if (propName) {
        if (!(propName in attrs)) {
          attrs[propName] = attrValue;
        }

        host.removeAttribute(attrName);
      }
    }

    return WithScope(
      { current: component.$$.scope },
      isFunction(children)
        ? children?.(
            {
              ...Object.fromEntries(host.attributes.tokens),
              ...attrs,
              style,
            },
            component,
          )
        : children,
      React.createElement(() => {
        host.destroy();
        return null;
      }),
    );
  }

  ServerComponent.displayName = Component.name + 'Bridge';
  return ServerComponent;
}

function useStateContext(
  state,
) {
  return useReactContext(state) ;
}

function useSignal(signal, key) {
  const [, scheduleReactUpdate] = React.useState();

  React.useEffect(() => {
    return effect(() => {
      signal();
      scheduleReactUpdate({});
    });
  }, [key ?? signal]);

  return signal();
}

function useSignalRecord($state) {
  const [, scheduleReactUpdate] = React.useState(),
    tracking = React.useRef(null) 



;

  if (tracking.current == null) {
    tracking.current = {
      state: {},
      $update: signal({}),
      props: new Set(),
    };
  }

  React.useEffect(() => {
    let { state, $update, props } = tracking.current;
    return effect$1(() => {
      for (const prop of props) {
        const value = $state[prop ]();
        state[prop] = isArray(value) ? [...value] : value;
      }

      $update();
      scheduleReactUpdate({});
    });
  }, [$state]);

  return React.useMemo(() => {
    let { state, $update, props } = tracking.current,
      scheduledUpdate = false;

    props.clear();

    return new Proxy(state, {
      get(_, prop) {
        if (!props.has(prop) && prop in $state) {
          props.add(prop);

          const value = $state[prop ]();
          state[prop] = isArray(value) ? [...value] : value;

          if (!scheduledUpdate) {
            $update.set({});
            scheduledUpdate = true;
            queueMicrotask(() => (scheduledUpdate = false));
          }
        }

        return state[prop];
      },
      set(_, prop, newValue) {
        if (!(prop in $state)) state[prop] = newValue;
        return true;
      },
    }) ;
  }, [$state]);
}

function createReactComponent(
  Component,
  options,
) {
  {
    return createServerComponent(Component, {
      props: new Set(Object.keys(Component.props || {})),
    });
  }
}

export { ReactScopeContext, WithScope, composeRefs, createReactComponent, createReactContextProvider, createReactScopeProvider, setRef, useReactContext, useReactScope, useSignal, useSignalRecord, useStateContext };
