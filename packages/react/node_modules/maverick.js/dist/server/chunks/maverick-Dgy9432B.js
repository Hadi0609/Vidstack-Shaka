import { createComputation, read, SCOPE, write, isFunction$1 as isFunction, update, dispose, onDispose, setContext, getScope, getContext, isUndefined, scoped, createScope, setAttribute, unwrapDeep, setStyle, root, DOMEvent, noop } from './maverick-gr-NKUum.js';

function signal(initialValue, options) {
  const node = createComputation(initialValue, null, options), signal2 = read.bind(node);
  signal2[SCOPE] = true;
  signal2.set = write.bind(node);
  return signal2;
}
function isReadSignal(fn) {
  return isFunction(fn) && SCOPE in fn;
}
function computed(compute, options) {
  const node = createComputation(
    options?.initial,
    compute,
    options
  ), signal2 = read.bind(node);
  signal2[SCOPE] = true;
  return signal2;
}
function effect(effect2, options) {
  const signal2 = createComputation(
    null,
    function runEffect() {
      let effectResult = effect2();
      isFunction(effectResult) && onDispose(effectResult);
      return null;
    },
    void 0
  );
  signal2.$e = true;
  update(signal2);
  return dispose.bind(signal2, true);
}
function readonly(signal2) {
  const readonly2 = () => signal2();
  readonly2[SCOPE] = true;
  return readonly2;
}
function isWriteSignal(fn) {
  return isReadSignal(fn) && "set" in fn;
}

function createContext(provide) {
  return { id: Symbol(), provide };
}

function provideContext(context, value, scope = getScope()) {

  const hasProvidedValue = !isUndefined(value);

  setContext(context.id, hasProvidedValue ? value : context.provide?.(), scope);
}

function useContext(context) {
  const value = getContext(context.id) ;

  return value;
}

function hasProvidedContext(context) {
  return !isUndefined(getContext(context.id));
}

const PROPS = /* #__PURE__ */ Symbol(0);
const METHODS = /* #__PURE__ */ Symbol(0);
const ON_DISPATCH = /* #__PURE__ */ Symbol(0);

const EMPTY_PROPS = {} ;



class Instance {
  /** @internal type only */
  $ts__events;
  /** @internal type only */
  $ts__vars;

  /* @internal */
  [ON_DISPATCH] = null;

   $el = signal(null);

  el = null;
  scope = null;
  attachScope = null;
  connectScope = null;
  component = null;
  destroyed = false;

  props = EMPTY_PROPS;
  attrs = null;
  styles = null;

  state;
  $state;

  #setupCallbacks = [];
  #attachCallbacks = [];
  #connectCallbacks = [];
  #destroyCallbacks = [];

  constructor(
    Component,
    scope,
    init,
  ) {
    this.scope = scope;
    if (init?.scope) init.scope.append(scope);

    let stateFactory = Component.state,
      props = Component.props;

    if (stateFactory) {
      this.$state = stateFactory.create();
      this.state = new Proxy(this.$state, {
        get: (_, prop) => this.$state[prop](),
      }) ;
      provideContext(stateFactory, this.$state);
    }

    if (props) {
      this.props = createInstanceProps(props) ;
      if (init?.props) {
        for (const prop of Object.keys(init.props)) {
          this.props[prop]?.set(init.props[prop]);
        }
      }
    }

    onDispose(this.destroy.bind(this));
  }

  setup() {
    scoped(() => {
      for (const callback of this.#setupCallbacks) callback();
    }, this.scope);
  }

  attach(el) {
    if (this.el) return;

    this.el = el ;
    this.$el.set(el );

    scoped(() => {
      this.attachScope = createScope();
      scoped(() => {
        for (const callback of this.#attachCallbacks) callback(this.el);
        this.#attachAttrs();
        this.#attachStyles();
      }, this.attachScope);
    }, this.scope);

    el.dispatchEvent(new Event('attached'));
  }

  detach() {
    this.attachScope?.dispose();
    this.attachScope = null;
    this.connectScope = null;

    this.el = null;
    this.$el.set(null);
  }

  connect() {
    if (!this.el || !this.attachScope || !this.#connectCallbacks.length) return;
    scoped(() => {
      this.connectScope = createScope();
      scoped(() => {
        for (const callback of this.#connectCallbacks) callback(this.el);
      }, this.connectScope);
    }, this.attachScope);
  }

  disconnect() {
    this.connectScope?.dispose();
    this.connectScope = null;
  }

  destroy() {
    if (this.destroyed) return;
    this.destroyed = true;

    scoped(() => {
      for (const callback of this.#destroyCallbacks) callback(this.el);
    }, this.scope);

    const el = this.el;

    this.detach();
    this.scope.dispose();

    this.#setupCallbacks.length = 0;
    this.#attachCallbacks.length = 0;
    this.#connectCallbacks.length = 0;
    this.#destroyCallbacks.length = 0;

    this.component = null;
    this.attrs = null;
    this.styles = null;
    this.props = EMPTY_PROPS;
    this.scope = null;
    this.state = EMPTY_PROPS;
    this.$state = null;
    // @ts-expect-error
    if (el) delete el.$;
  }

  addHooks(target) {
    if (target.onSetup) this.#setupCallbacks.push(target.onSetup.bind(target));
    if (target.onAttach) this.#attachCallbacks.push(target.onAttach.bind(target));
    if (target.onConnect) this.#connectCallbacks.push(target.onConnect.bind(target));
    if (target.onDestroy) this.#destroyCallbacks.push(target.onDestroy.bind(target));
  }

  #attachAttrs() {
    if (!this.attrs) return;
    for (const name of Object.keys(this.attrs)) {
      {
        setAttribute(this.el, name, unwrapDeep.call(this.component, this.attrs[name]));
      }
    }
  }

  #attachStyles() {
    if (!this.styles) return;
    for (const name of Object.keys(this.styles)) {
      {
        setStyle(this.el, name, unwrapDeep.call(this.component, this.styles[name]));
      }
    }
  }

  #setAttr(name) {
    setAttribute(this.el, name, (this.attrs[name] ).call(this.component));
  }

  #setStyle(name) {
    setStyle(this.el, name, (this.styles[name] ).call(this.component));
  }
}

function createInstanceProps(props) {
  const $props = {} ;

  for (const name of Object.keys(props )) {
    const def = props[name];
    $props[name] = signal(def, def);
  }

  return $props;
}

// Match component interface.
let currentInstance = { $$: null };

function createComponent(
  Component,
  init,
) {
  return root(() => {
    currentInstance.$$ = new Instance(Component, getScope(), init);
    const component = new Component();
    currentInstance.$$.component = component;
    currentInstance.$$ = null;
    return component;
  });
}

class ViewController extends EventTarget {
  /** @internal */
  $$;

  get el() {
    return this.$$.el;
  }

  get $el() {
    return this.$$.$el();
  }

  get scope() {
    return this.$$.scope;
  }

  get attachScope() {
    return this.$$.attachScope;
  }

  get connectScope() {
    return this.$$.connectScope;
  }

  /** @internal */
  get $props() {
    return this.$$.props;
  }

  /** @internal */
  get $state() {
    return this.$$.$state;
  }

  get state() {
    return this.$$.state;
  }

  constructor() {
    super();
    if (currentInstance.$$) this.attach(currentInstance );
  }

  attach({ $$ }) {
    this.$$ = $$;
    $$.addHooks(this );
    return this;
  }

   addEventListener(
    type,
    callback,
    options,
  ) {

    this.listen(type , callback , options);
  }

   removeEventListener(
    type,
    callback,
    options,
  ) {
    this.el?.removeEventListener(type, callback , options);
  }

  /**
   * The given callback is invoked when the component is ready to be set up.
   *
   * - This hook will run once.
   * - This hook is called both client-side and server-side.
   * - It's safe to use context inside this hook.
   * - The host element has not attached yet - wait for `onAttach`.
   */
  



























  /**
   * This method can be used to specify attributes that should be set on the host element. Any
   * attributes that are assigned to a function will be considered a signal and updated accordingly.
   */
   setAttributes(attributes) {
    if (!this.$$.attrs) this.$$.attrs = {};
    Object.assign(this.$$.attrs, attributes);
  }

  /**
   * This method can be used to specify styles that should set be set on the host element. Any
   * styles that are assigned to a function will be considered a signal and updated accordingly.
   */
   setStyles(styles) {
    if (!this.$$.styles) this.$$.styles = {};
    Object.assign(this.$$.styles, styles);
  }

  /**
   * This method is used to satisfy the CSS variables contract specified on the current
   * component. Other CSS variables can be set via the `setStyles` method.
   */
   setCSSVars(vars) {
    this.setStyles(vars );
  }

  /**
   * Type-safe utility for creating component DOM events.
   */
  createEvent(
    type,
    ...init




  ) {
    return new DOMEvent(type, init[0] ) ;
  }

  /**
   * Creates a `DOMEvent` and dispatches it from the host element. This method is typed to
   * match all component events.
   */
  dispatch(
    type,
    ...init








  ) {
    return false;
  }

   dispatchEvent(event) {
    return this.dispatch(event);
  }

  /**
   * Adds an event listener for the given `type` and returns a function which can be invoked to
   * remove the event listener.
   *
   * - The listener is removed if the current scope is disposed.
   * - This method is safe to use on the server (noop).
   */
  listen(
    type,
    handler,
    options,
  ) {
    return noop;
  }
}

export { Instance, METHODS, PROPS, ViewController, computed, createComponent, createContext, effect, hasProvidedContext, isReadSignal, isWriteSignal, provideContext, readonly, signal, useContext };
