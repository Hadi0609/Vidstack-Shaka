const SCOPE = Symbol(0);

let scheduledEffects = false, runningEffects = false, currentScope = null, currentObserver = null, currentObservers = null, currentObserversIndex = 0, effects = [], defaultContext = {};
const NOOP = () => {
}, STATE_CLEAN = 0, STATE_CHECK = 1, STATE_DIRTY = 2, STATE_DISPOSED = 3;
function flushEffects() {
  scheduledEffects = true;
  queueMicrotask(runEffects);
}
function runEffects() {
  if (!effects.length) {
    scheduledEffects = false;
    return;
  }
  runningEffects = true;
  for (let i = 0; i < effects.length; i++) {
    if (effects[i].$st !== STATE_CLEAN)
      runTop(effects[i]);
  }
  effects = [];
  scheduledEffects = false;
  runningEffects = false;
}
function runTop(node) {
  let ancestors = [node];
  while (node = node[SCOPE]) {
    if (node.$e && node.$st !== STATE_CLEAN)
      ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    updateCheck(ancestors[i]);
  }
}
function root(init) {
  const scope = createScope();
  return compute(scope, !init.length ? init : init.bind(null, dispose.bind(scope)), null);
}
function peek(fn) {
  return compute(currentScope, fn, null);
}
function untrack(fn) {
  return compute(null, fn, null);
}
function tick() {
  if (!runningEffects)
    runEffects();
}
function getScope() {
  return currentScope;
}
function scoped(run, scope) {
  try {
    return compute(scope, run, null);
  } catch (error) {
    handleError(scope, error);
    return;
  }
}
function getContext(key, scope = currentScope) {
  return scope?.$cx[key];
}
function setContext(key, value, scope = currentScope) {
  if (scope)
    scope.$cx = { ...scope.$cx, [key]: value };
}
function onError(handler) {
  if (!currentScope)
    return;
  currentScope.$eh = currentScope.$eh ? [handler, ...currentScope.$eh] : [handler];
}
function onDispose(disposable) {
  if (!disposable || !currentScope)
    return disposable || NOOP;
  const node = currentScope;
  if (!node.$d) {
    node.$d = disposable;
  } else if (Array.isArray(node.$d)) {
    node.$d.push(disposable);
  } else {
    node.$d = [node.$d, disposable];
  }
  return function removeDispose() {
    if (node.$st === STATE_DISPOSED)
      return;
    disposable.call(null);
    if (isFunction$1(node.$d)) {
      node.$d = null;
    } else if (Array.isArray(node.$d)) {
      node.$d.splice(node.$d.indexOf(disposable), 1);
    }
  };
}
function dispose(self = true) {
  if (this.$st === STATE_DISPOSED)
    return;
  if (this.$h) {
    if (Array.isArray(this.$h)) {
      for (let i = this.$h.length - 1; i >= 0; i--) {
        dispose.call(this.$h[i]);
      }
    } else {
      dispose.call(this.$h);
    }
  }
  if (self) {
    const parent = this[SCOPE];
    if (parent) {
      if (Array.isArray(parent.$h)) {
        parent.$h.splice(parent.$h.indexOf(this), 1);
      } else {
        parent.$h = null;
      }
    }
    disposeNode(this);
  }
}
function disposeNode(node) {
  node.$st = STATE_DISPOSED;
  if (node.$d)
    emptyDisposal(node);
  if (node.$s)
    removeSourceObservers(node, 0);
  node[SCOPE] = null;
  node.$s = null;
  node.$o = null;
  node.$h = null;
  node.$cx = defaultContext;
  node.$eh = null;
}
function emptyDisposal(scope) {
  try {
    if (Array.isArray(scope.$d)) {
      for (let i = scope.$d.length - 1; i >= 0; i--) {
        const callable = scope.$d[i];
        callable.call(callable);
      }
    } else {
      scope.$d.call(scope.$d);
    }
    scope.$d = null;
  } catch (error) {
    handleError(scope, error);
  }
}
function compute(scope, compute2, observer) {
  const prevScope = currentScope, prevObserver = currentObserver;
  currentScope = scope;
  currentObserver = observer;
  try {
    return compute2.call(scope);
  } finally {
    currentScope = prevScope;
    currentObserver = prevObserver;
  }
}
function handleError(scope, error) {
  if (!scope || !scope.$eh)
    throw error;
  let i = 0, len = scope.$eh.length, currentError = error;
  for (i = 0; i < len; i++) {
    try {
      scope.$eh[i](currentError);
      break;
    } catch (error2) {
      currentError = error2;
    }
  }
  if (i === len)
    throw currentError;
}
function read() {
  if (this.$st === STATE_DISPOSED)
    return this.$v;
  if (currentObserver && !this.$e) {
    if (!currentObservers && currentObserver.$s && currentObserver.$s[currentObserversIndex] == this) {
      currentObserversIndex++;
    } else if (!currentObservers)
      currentObservers = [this];
    else
      currentObservers.push(this);
  }
  if (this.$c)
    updateCheck(this);
  return this.$v;
}
function write(newValue) {
  const value = isFunction$1(newValue) ? newValue(this.$v) : newValue;
  if (this.$ch(this.$v, value)) {
    this.$v = value;
    if (this.$o) {
      for (let i = 0; i < this.$o.length; i++) {
        notify(this.$o[i], STATE_DIRTY);
      }
    }
  }
  return this.$v;
}
const ScopeNode = function Scope() {
  this[SCOPE] = null;
  this.$h = null;
  if (currentScope)
    currentScope.append(this);
};
const ScopeProto = ScopeNode.prototype;
ScopeProto.$cx = defaultContext;
ScopeProto.$eh = null;
ScopeProto.$c = null;
ScopeProto.$d = null;
ScopeProto.append = function(child) {
  child[SCOPE] = this;
  if (!this.$h) {
    this.$h = child;
  } else if (Array.isArray(this.$h)) {
    this.$h.push(child);
  } else {
    this.$h = [this.$h, child];
  }
  child.$cx = child.$cx === defaultContext ? this.$cx : { ...this.$cx, ...child.$cx };
  if (this.$eh) {
    child.$eh = !child.$eh ? this.$eh : [...child.$eh, ...this.$eh];
  }
};
ScopeProto.dispose = function() {
  dispose.call(this);
};
function createScope() {
  return new ScopeNode();
}
const ComputeNode = function Computation(initialValue, compute2, options) {
  ScopeNode.call(this);
  this.$st = compute2 ? STATE_DIRTY : STATE_CLEAN;
  this.$i = false;
  this.$e = false;
  this.$s = null;
  this.$o = null;
  this.$v = initialValue;
  if (compute2)
    this.$c = compute2;
  if (options && options.dirty)
    this.$ch = options.dirty;
};
const ComputeProto = ComputeNode.prototype;
Object.setPrototypeOf(ComputeProto, ScopeProto);
ComputeProto.$ch = isNotEqual;
ComputeProto.call = read;
function createComputation(initialValue, compute2, options) {
  return new ComputeNode(initialValue, compute2, options);
}
function isNotEqual(a, b) {
  return a !== b;
}
function isFunction$1(value) {
  return typeof value === "function";
}
function updateCheck(node) {
  if (node.$st === STATE_CHECK) {
    for (let i = 0; i < node.$s.length; i++) {
      updateCheck(node.$s[i]);
      if (node.$st === STATE_DIRTY) {
        break;
      }
    }
  }
  if (node.$st === STATE_DIRTY)
    update(node);
  else
    node.$st = STATE_CLEAN;
}
function cleanup(node) {
  if (node.$h)
    dispose.call(node, false);
  if (node.$d)
    emptyDisposal(node);
  node.$eh = node[SCOPE] ? node[SCOPE].$eh : null;
}
function update(node) {
  let prevObservers = currentObservers, prevObserversIndex = currentObserversIndex;
  currentObservers = null;
  currentObserversIndex = 0;
  try {
    cleanup(node);
    const result = compute(node, node.$c, node);
    updateObservers(node);
    if (!node.$e && node.$i) {
      write.call(node, result);
    } else {
      node.$v = result;
      node.$i = true;
    }
  } catch (error) {
    updateObservers(node);
    handleError(node, error);
  } finally {
    currentObservers = prevObservers;
    currentObserversIndex = prevObserversIndex;
    node.$st = STATE_CLEAN;
  }
}
function updateObservers(node) {
  if (currentObservers) {
    if (node.$s)
      removeSourceObservers(node, currentObserversIndex);
    if (node.$s && currentObserversIndex > 0) {
      node.$s.length = currentObserversIndex + currentObservers.length;
      for (let i = 0; i < currentObservers.length; i++) {
        node.$s[currentObserversIndex + i] = currentObservers[i];
      }
    } else {
      node.$s = currentObservers;
    }
    let source;
    for (let i = currentObserversIndex; i < node.$s.length; i++) {
      source = node.$s[i];
      if (!source.$o)
        source.$o = [node];
      else
        source.$o.push(node);
    }
  } else if (node.$s && currentObserversIndex < node.$s.length) {
    removeSourceObservers(node, currentObserversIndex);
    node.$s.length = currentObserversIndex;
  }
}
function notify(node, state) {
  if (node.$st >= state)
    return;
  if (node.$e && node.$st === STATE_CLEAN) {
    effects.push(node);
    if (!scheduledEffects)
      flushEffects();
  }
  node.$st = state;
  if (node.$o) {
    for (let i = 0; i < node.$o.length; i++) {
      notify(node.$o[i], STATE_CHECK);
    }
  }
}
function removeSourceObservers(node, index) {
  let source, swap;
  for (let i = index; i < node.$s.length; i++) {
    source = node.$s[i];
    if (source.$o) {
      swap = source.$o.indexOf(node);
      source.$o[swap] = source.$o[source.$o.length - 1];
      source.$o.pop();
    }
  }
}

function noop(...args) {}

function isNull(value) {
  return value === null;
}

function isUndefined(value) {
  return typeof value === 'undefined';
}

function isNil(value) {
  return isNull(value) || isUndefined(value);
}

function isObject(value) {
  return value?.constructor === Object;
}

function isNumber(value) {
  return typeof value === 'number' && !Number.isNaN(value);
}

function isString(value) {
  return typeof value === 'string';
}

function isBoolean(value) {
  return typeof value === 'boolean';
}

function isFunction(value) {
  return typeof value === 'function';
}

function isArray(value) {
  return Array.isArray(value);
}

function createRegex(regex) {
  return isString(regex) ? new RegExp(regex) : regex;
}

function isWindow(value) {
  return value === window;
}

const EVENT = Event,
  DOM_EVENT = Symbol('DOM_EVENT');






class DOMEvent extends EVENT {
  [DOM_EVENT] = true;

  /**
   * The event detail.
   */
   detail;

  /**
   * The event trigger chain.
   */
   triggers = new EventTriggers();

  /**
   * The preceding event that was responsible for this event being fired.
   */
  get trigger() {
    return this.triggers.source;
  }

  /**
   * The origin event that lead to this event being fired.
   */
  get originEvent() {
    return this.triggers.origin;
  }

  /**
   * Whether the origin event was triggered by the user.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted}
   */
  get isOriginTrusted() {
    return this.triggers.origin?.isTrusted ?? false;
  }

  constructor(
    type,
    ...init


  ) {
    super(type, init[0]);
    this.detail = init[0]?.detail;

    const trigger = init[0]?.trigger;
    if (trigger) this.triggers.add(trigger);
  }
}

class EventTriggers  {
   chain = [];

  get source() {
    return this.chain[0];
  }

  get origin() {
    return this.chain[this.chain.length - 1];
  }

  /**
   * Appends the event to the end of the chain.
   */
  add(event) {
    this.chain.push(event);
    if (isDOMEvent(event)) {
      this.chain.push(...event.triggers);
    }
  }

  /**
   * Removes the event from the chain and returns it (if found).
   */
  remove(event) {
    return this.chain.splice(this.chain.indexOf(event), 1)[0];
  }

  /**
   * Returns whether the chain contains the given `event`.
   */
  has(event) {
    return this.chain.some((e) => e === event);
  }

  /**
   * Returns whether the chain contains the given event type.
   */
  hasType(type) {
    return !!this.findType(type);
  }

  /**
   * Returns the first event with the given `type` found in the chain.
   */
  findType(type) {
    return this.chain.find((e) => e.type === type);
  }

  /**
   * Walks an event chain on a given `event`, and invokes the given `callback` for each trigger event.
   */
  walk(
    callback,
  ) {
    for (const event of this.chain) {
      const returnValue = callback(event);
      if (returnValue) return [event, returnValue];
    }
  }

  [Symbol.iterator]() {
    return this.chain.values();
  }
}

/**
 * Whether the given `event` is a `DOMEvent` class.
 */
function isDOMEvent(event) {
  return !!event?.[DOM_EVENT];
}

/**
 * Walks up the event chain (following each `trigger`) and returns the origin event that
 * started the chain.
 * @deprecated - Use `event.originEvent`
 */
function getOriginEvent(event) {
  return event.originEvent;
}

/**
 * Walks an event chain on a given `event`, and invokes the given `callback` for each trigger event.
 * @deprecated - Use `event.triggers.walk(callback)`
 */
function walkTriggerEventChain(
  event,
  callback,
) {
  if (!isDOMEvent(event)) return;
  return event.triggers.walk(callback);
}

/**
 * Attempts to find a trigger event with a given `eventType` on the event chain.
 * @deprecated - Use `event.triggers.findType('')`
 */
function findTriggerEvent(event, type) {
  return isDOMEvent(event) ? event.triggers.findType(type) : undefined;
}

/**
 * Whether a trigger event with the given `eventType` exists can be found in the event chain.
 * @deprecated - Use `event.triggers.hasType('')`
 */
function hasTriggerEvent(event, type) {
  return !!findTriggerEvent(event, type);
}

/**
 * Appends the given `trigger` to the event chain.
 * @deprecated - Use `event.triggers.add(event)`
 */
function appendTriggerEvent(event, trigger) {
  if (trigger) event.triggers.add(trigger);
}






















class EventsTarget extends EventTarget {
  /** @internal type only */
  $ts__events;
   addEventListener(
    type,
    callback,
    options,
  ) {
    return super.addEventListener(type , callback , options);
  }
   removeEventListener(
    type,
    callback,
    options,
  ) {
    return super.removeEventListener(type , callback , options);
  }
}

















/**
 * Adds an event listener for the given `type` and returns a function which can be invoked to
 * remove the event listener.
 *
 * - The listener is removed if the current scope is disposed.
 * - This function is safe to use on the server (noop).
 */
function listenEvent



(
  target,
  type,
  handler,
  options,
) {
  target.addEventListener(type, handler , options);
  return onDispose(() => target.removeEventListener(type, handler , options));
}

class EventsController {
  #target;
  #controller;

  get signal() {
    return this.#controller.signal;
  }

  constructor(target) {
    this.#target = target;
    this.#controller = new AbortController();
    onDispose(this.abort.bind(this));
  }

  add(
    type,
    handler,
    options,
  ) {
    if (this.signal.aborted) throw Error('aborted');

    this.#target.addEventListener(type , handler , {
      ...options,
      signal: options?.signal ? anySignal(this.signal, options.signal) : this.signal,
    });

    return this;
  }

  remove(
    type,
    handler,
  ) {
    this.#target.removeEventListener(type , handler );
    return this;
  }

  abort(reason) {
    this.#controller.abort(reason);
  }
}

/**
 * Returns an `AbortSignal` that will abort when any of the given signals are aborted.
 */
function anySignal(...signals) {
  const controller = new AbortController(),
    options = { signal: controller.signal };

  function onAbort(event) {
    controller.abort((event.target ).reason);
  }

  for (const signal of signals) {
    if (signal.aborted) {
      controller.abort(signal.reason);
      break;
    }

    signal.addEventListener('abort', onAbort, options);
  }

  return controller.signal;
}

function isPointerEvent(event) {
  return !!event?.type.startsWith('pointer');
}

function isTouchEvent(event) {
  return !!event?.type.startsWith('touch');
}

function isMouseEvent(event) {
  return /^(click|mouse)/.test(event?.type ?? '');
}

function isKeyboardEvent(event) {
  return !!event?.type.startsWith('key');
}

function wasEnterKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === 'Enter';
}

function wasEscapeKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === 'Escape';
}

function isKeyboardClick(event) {
  return isKeyboardEvent(event) && (event.key === 'Enter' || event.key === ' ');
}

function isDOMNode(node) {
  return node instanceof Node;
}

function isDOMElement(node) {
  return isDOMNode(node) && node.nodeType === 1;
}

function isDOMFragment(node) {
  return isDOMNode(node) && node.nodeType === 11;
}

function createFragment() {
  return document.createDocumentFragment();
}

function createComment(data) {
  return document.createComment(data);
}

/**
 * Sets or removes the given attribute `value`. Falsy values except `''` and `0` will remove
 * the attribute. If the given `value` is a function/signal, the attribute will be updated as
 * the value updates.
 *
 * This function is safe to use on the server.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Falsy}
 */
function setAttribute(
  host,
  name,
  value,
) {
  if (!host) return;
  else if (!value && value !== '' && value !== 0) {
    host.removeAttribute(name);
  } else {
    const attrValue = value === true ? '' : value + '';
    if (host.getAttribute(name) !== attrValue) {
      host.setAttribute(name, attrValue);
    }
  }
}

/**
 * Sets or removes the given style `value`. Falsy values will remove the style. If the
 * given `value` is a function/signal, the style will be updated as the value updates.
 *
 * This function is safe to use on the server.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Falsy}
 */
function setStyle(
  host,
  property,
  value,
) {
  if (!host) return;
  else if (!value && value !== 0) {
    host.style.removeProperty(property);
  } else {
    host.style.setProperty(property, value + '');
  }
}

/**
 * Toggles the given class `name`. Falsy values will remove the class from the list. If the
 * given `value` is a function/signal, the class will be toggled as the value updates.
 *
 * This function is safe to use on the server.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Falsy}
 */
function toggleClass(host, name, value) {
  host.classList[value ? 'add' : 'remove'](name);
}

/**
 * Returns elements assigned to the given slot in the shadow root. Filters out all nodes
 * which are not an element.
 *
 * @param el - The element containing the slot.
 * @param name - The name of the slot (optional).
 */
function getSlottedChildren(el, name) {
  const selector = name ? `slot[name="${name}"]` : 'slot:not([name])';
  const slot = el.shadowRoot?.querySelector(selector) ;
  const childNodes = slot?.assignedNodes({ flatten: true }) ?? [];
  return Array.prototype.filter.call(childNodes, (node) => node.nodeType == 1);
}

function attachDeclarativeShadowDOM(element) {
  const template = element.firstChild ;
  const mode = template.getAttribute('shadowroot') ;
  const shadowRoot = (template.parentNode ).attachShadow({ mode });
  shadowRoot.appendChild(template.content);
  template.remove();
}

export { DOMEvent, EventTriggers, EventsController, EventsTarget, SCOPE, anySignal, appendTriggerEvent, attachDeclarativeShadowDOM, createComment, createComputation, createFragment, createRegex, createScope, dispose, findTriggerEvent, getContext, getOriginEvent, getScope, getSlottedChildren, hasTriggerEvent, isArray, isBoolean, isDOMElement, isDOMEvent, isDOMFragment, isDOMNode, isFunction, isFunction$1, isKeyboardClick, isKeyboardEvent, isMouseEvent, isNil, isNull, isNumber, isObject, isPointerEvent, isString, isTouchEvent, isUndefined, isWindow, listenEvent, noop, onDispose, onError, peek, read, root, scoped, setAttribute, setContext, setStyle, tick, toggleClass, untrack, update, walkTriggerEventChain, wasEnterKeyPressed, wasEscapeKeyPressed, write };
